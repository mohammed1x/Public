
21 



A Web Application Hacker's 

Methodology 



This chapter contains a detailed step-by-step methodology you can follow when 
attacking a web application. It covers all the categories of vulnerabilities and 
attack techniques described in this book. Following all the steps in this meth- 
odology will not guarantee that you discover all the vulnerabilities within a 
given application. However, it will provide you with a good level of assurance 
that you have probed all the necessary regions of the application's attack surface 
and have found as many issues as possible given the resources available to you. 

Figure 21-1 illustrates the main areas of work that this methodology describes. 
We will drill down into this diagram and illustrate the subdivision of tasks that 
each area involves. The numbers in the diagrams correspond to the hierarchical 
numbered list used in the methodology, so you can easily jump to the actions 
involved in a specific area. 

The methodology is presented as a sequence of tasks that are organized and 
ordered according to the logical interdependencies between them. As far as pos- 
sible, these interdependencies are highlighted in the task descriptions. However, 
in practice you will frequently need to think imaginatively about the direction 
in which your activities should go and allow these to be guided by what you 
discover about the application you are attacking. For example: 

■ Information gathered in one stage may enable you to return to an earlier 
stage and formulate more focused attacks. For example, an access control 
bug that enables you to obtain a listing of all users may enable you to 



791 



792 Chapter 21 A Web Application Hacker's Methodology 



perform a more effective password-guessing attack against the authen- 
tication function. 

■ Discovering a key vulnerability in one area of the application may enable 
you to shortcut some of the work in other areas. For example, a file disclosure 
vulnerability may enable to you perform a code review of key application 
functions rather than probing them in a solely black-box manner. 

■ The results of your testing in some areas may highlight patterns of recur- 
ring vulnerabilities that you can immediately probe for in other areas. 
For example, a generic defect in the application's input validation filters 
may enable you to quickly find a bypass of its defenses against several 
different categories of attack. 



Recon and analysis 



1. Map application content 



2. Analyze the application 



Application logic 



Access handling 



Input handling 



Application hosting 



3. Test client-side 
controls 



9. Test for logic 
flaws 



4. Test 
authentication 



5. Test session 
management 



6. Test access 
controls 



7. Fuzz all 
parameters 



. Test for issues 
with specific 
functionality 



10. Test for shared 
hosting issues 



11. Test the web 
server 



12. Miscellaneous 
Checks 



13. Information 
Leakage 



Figure 21-1: The main areas of work involved in the methodology 



Use the steps in this methodology to guide your work, and as a checklist to 
avoid oversights, but do not feel obligated to adhere to them too rigidly. Keep 



Chapter 21 A Web Application Hacker's Methodology 795 



the following thought in mind: the tasks we describe are largely standard and 
orthodox; the most impressive attacks against web applications always involve 
thinking beyond them. 

General Guidelines 



You should always keep in mind some general considerations when carrying out 
the detailed tasks involved in attacking a web application. These may apply to all 
the different areas you need to examine and techniques you need to carry out. 

■ Remember that several characters have special meaning in different parts 
of the HTTP request. When you are modifying the data within requests, 
you should URL-encode these characters to ensure that they are interpreted 
in the way you intend: 

■ & is used to separate parameters in the URL query string and message 
body. To insert a literal & character, you should encode this as %2 6. 

■ = is used to separate the name and value of each parameter in the URL 
query string and message body. To insert a literal = character, you 
should encode this as %3d. 

■ ? is used to mark the beginning of the URL query string. To insert a 
literal ? character, you should encode this as %3 f . 

■ A space is used to mark the end of the URL in the first line of requests 
and can indicate the end of a cookie value in the Cookie header. To 
insert a literal space, you should encode this as %2 or +. 

■ Because + represents an encoded space, to insert a literal + character, 
you should encode this as %2b. 

■ ,- is used to separate individual cookies in the Cookie header. To insert 
a literal ; character, you should encode this as %3b. 

■ # is used to mark the fragment identifier within the URL. If you enter 
this character into the URL within your browser, it effectively truncates 
the URL that is sent to the server. To insert a literal # character, you 
should encode this as %2 3. 

■ % is used as the prefix in the URL-encoding scheme. To insert a literal 
% character, you should encode this as %2 5. 

■ Any nonprinting characters such as null bytes and newlines must, of 
course, be URL-encoded using their ASCII character code — in this 
case, as %oo and %0a, respectively. 

■ Furthermore, note that entering URL-encoded data into a form usually 
causes your browser to perform another layer of encoding. For example, 



794 Chapter 21 A Web Application Hacker's Methodology 



submitting %oo in a form will probably result in a value of %2 500 being 
sent to the server. For this reason it is normally best to observe the final 
request within an intercepting proxy. 

■ Many tests for common web application vulnerabilities involve sending 
various crafted input strings and monitoring the application's responses 
for anomalies, which indicate that a vulnerability is present. In some 
cases, the application's response to a particular request contains a signa- 
ture of a particular vulnerability, regardless of whether a trigger for that 
vulnerability has been submitted. In any case where specific crafted input 
results in behavior associated with a vulnerability (such as a particular 
error message), you should double-check whether submitting benign 
input in the relevant parameter also causes the same behavior. If it does, 
your tentative finding is probably a false positive. 

■ Applications typically accumulate an amount of state from previous requests, 
which affects how they respond to further requests. Sometimes, when you 
are trying to investigate a tentative vulnerability and isolate the precise 
cause of a particular piece of anomalous behavior, you must remove the 
effects of any accumulated state. To do so, it is usually sufficient to begin 
a fresh session with a new browser process, navigate to the location of the 
observed anomaly using only benign requests, and then resubmit your 
crafted input. You can often replicate this measure by adjusting the parts 
of your requests containing cookies and caching information. Furthermore, 
you can use a tool such as Burp Repeater to isolate a request, make specific 
adjustments to it, and reissue it as many times as you require. 

■ Some applications use a load-balanced configuration in which consecu- 
tive HTTP requests may be handled by different back-end servers at the 
web, presentation, data, or other tiers. Different servers may have small 
differences in configuration that affect your results. Furthermore, some 
successful attacks will result in a change in the state of the specific server 
that handles your requests — such as the creation of a new file within the 
web root. To isolate the effects of particular actions, it may be necessary 
to perform several identical requests in succession, testing the result of 
each until your request is handled by the relevant server. 

Assuming that you are implementing this methodology as part of a consul- 
tancy engagement, you should always be sure to carry out the usual scoping 
exercise to agree precisely which hostnames, URLs, and functionality are to 
be included, and whether any restrictions exist on the types of testing you are 
permitted to perform. You should make the application owner aware of the 
inherent risks involved in performing any kind of penetration testing against 
a black-box target. Advise the owner to back up any important data before you 
commence your work. 



Chapter 21 A Web Application Hacker's Methodology 795 



1 Map the Application's Content 



Linked content 




Other content 




Non-standard 
access methods 




1.1. Explore visible 
content 








1.3. Discover 
hidden content 








1.5. Identifier- 
specified functions 
















1.2. Consult public 
resources 








1.4. Discover 
default content 








1.6. Debug 
parameters 















Figure 21-2: Mapping the application's content 



1.1 Explore Visible Content 

1.1.1 Configure your browser to use your favorite integrated proxy / spidering 
tool. Both Burp and WebScarab can be used to passively spider the site 
by monitoring and parsing web content processed by the proxy. 

1.1.2 If you find it useful, configure your browser to use an extension such 
as IEWatch to monitor and analyze the HTTP and HTML content being 
processed by the browser. 

1.1.3 Browse the entire application in the normal way, visiting every link and 
URL, submitting every form, and proceeding through all multistep func- 
tions to completion. Try browsing with JavaScript enabled and disabled, 
and with cookies enabled and disabled. Many applications can handle 
various browser configurations, and you may reach different content 
and code paths within the application. 

1.1.4 If the application uses authentication, and you have or can create a login 
account, use this to access the protected functionality. 

1.1.5 As you browse, monitor the requests and responses passing through 
your intercepting proxy to gain an understanding of the kinds of data 
being submitted and the ways in which the client is used to control the 
behavior of the server-side application. 

1.1.6 Review the site map generated by the passive spidering, and identify any 
content or functionality that you have not walked through using your 
browser. From the spider results, establish where each item was discov- 
ered (for example, in Burp Spider, check the Linked From details). Access 
each item using your browser so that the spider parses the response from 
the server to identify any further content. Continue this step recursively 
until no further content or functionality is identified. 



796 Chapter 21 A Web Application Hacker's Methodology 



1.1.7 When you have finished manually browsing and passively spidering, 
you can use your spider to actively crawl the application, using the set 
of discovered URLs as seeds. This may sometimes uncover additional 
content that you overlooked when working manually. Before doing an 
automated crawl, first identify any URLs that are dangerous or likely to 
break the application session, and then configure the spider to exclude 
these from its scope. 

1.2 Consult Public Resources 

1.2.1 Use Internet search engines and archives (such as the Wayback Machine) 
to identify what content they have indexed and stored for your target 
application. 

1 .2.2 Use advanced search options to improve the effectiveness of your research. 
For example, on Google you can use site : to retrieve all the content for 
your target site and link: to retrieve other sites that link to it. If your 
search identifies content that is no longer present in the live application, 
you may still be able to view this from the search engine's cache. This 
old content may contain links to additional resources that have not yet 
been removed. 

1.2.3 Perform searches on any names and e-mail addresses you have discov- 
ered in the application's content, such as contact information. Include 
items not rendered on-screen, such as HTML comments. In addition to 
web searches, perform news and group searches. Look for any technical 
details posted to Internet forums regarding the target application and 
its supporting infrastructure. 

1.2.4 Review any published WSDL files to generate a list of function names 
and parameter values potentially employed by the application. 

1.3 Discover Hidden Content 

1.3.1 Confirm how the application handles requests for nonexistent items. 
Make some manual requests for known valid and invalid resources, 
and compare the server's responses to establish an easy way to identify 
when an item does not exist. 

1.3.2 Obtain listings of common file and directory names and common file 
extensions. Add to these lists all the items actually observed within the 
applications, and also items inferred from these. Try to understand the 
naming conventions used by application developers. For example, if 
there are pages called AddDocument . j sp and viewDocument . j sp, there 
may also be pages called EditDocument . j sp and RemoveDocument . j sp. 



Chapter 21 A Web Application Hacker's Methodology 797 



1 .3.3 Review all client-side code to identify any clues about hidden server-side 
content, including HTML comments and disabled form elements. 

1.3.4 Using the automation techniques described in Chapter 14, make large 
numbers of requests based on your directory, filename, and file extension 
lists. Monitor the server's responses to confirm which items are present 
and accessible. 

1 .3.5 Perform these content-discovery exercises recursively, using new enumer- 
ated content and patterns as the basis for further user-directed spidering 
and further automated discovery. 

1.4 Discover Default Content 

1.4.1 Run Nikto against the web server to detect any default or well-known 
content that is present. Use Nikto's options to maximize its effective- 
ness. For example, you can use the -root option to specify a directory 
to check for default content, or -404 to specify a string that identifies a 
custom File Not Found page. 

1.4.2 Verify any potentially interesting findings manually to eliminate any 
false positives within the results. 

1.4.3 Request the server's root directory, specifying the IP address in the 
Host header, and determine if the application responds with any dif- 
ferent content. If so, run a Nikto scan against the IP address as well as 
the server name. 

1.4.4 Make a request to the server's root directory, specifying a range of 
User-Agent headers, as shown at www.useragentstring . com/pages/ 
useragentstring . php. 

1.5 Enumerate Identifier-Specified Functions 

1.5.1 Identify any instances where specific application functions are accessed by 
passing an identifier of the function in a request parameter (for example, 

/admin . j sp?action=editUser or /main . php?f unc=A2 1). 

1 .5.2 Apply the content discovery techniques used in step 1 .3 to the mechanism 
being used to access individual functions. For example, if the applica- 
tion uses a parameter containing a function name, first determine its 
behavior when an invalid function is specified, and try to establish an 
easy way to identify when a valid function has been requested. Compile 
a list of common function names or cycle through the syntactic range of 
identifiers observed to be in use. Automate the exercise to enumerate 
valid functionality as quickly and easily as possible. 



798 Chapter 21 A Web Application Hacker's Methodology 



1.5.3 If applicable, compile a map of application content based on functional paths, 
rather than URLs, showing all the enumerated functions and the logical 
paths and dependencies between them. (See Chapter 4 for an example.) 

1.6 Test for Debug Parameters 

1.6.1 Choose one or more application pages or functions where hidden debug 
parameters (such as debug=true) maybe implemented. These are most 
likely to appear in key functionality such as login, search, and file upload 
or download. 

1.6.2 Use listings of common debug parameter names (such as debug, test, 
hide, and source) and common values (such as true, yes, on, and l). 
Iterate through all permutations of these, submitting each name /value 
pair to each targeted function. For post requests, supply the parameter 
in both the URL query string and the request body. Use the techniques 
described in Chapter 14 to automate this exercise. For example, you 
can use the cluster bomb attack type in Burp Intruder to combine all 
permutations of two payload lists. 

1 .6.3 Review the application's responses for any anomalies that may indicate 
that the added parameter has had an effect on the application's processing. 

2 Analyze the Application 



2.1. Identify 
functionality 



2.2. Identify data 
entry points 



2.3. Identify 
technologies 



2.4. Map the attack surface 



Figure 21-3: Analyzing the application 



2.1 Identify Functionality 

2.1.1 Identify the core functionality that the application was created for and 
the actions that each function is designed to perform when used as 
intended. 

2.1.2 Identify the core security mechanisms employed by the application and 
how they work. In particular, understand the key mechanisms that handle 



Chapter 21 A Web Application Hacker's Methodology 799 



authentication, session management, and access control, and the functions 
that support them, such as user registration and account recovery. 

2.1.3 Identify all the more peripheral functions and behavior, such as the use 
of redirects, off-site links, error messages, and administrative and log- 
ging functions. 

2.1.4 Identify any functionality that diverges from the standard GUI appear- 
ance, parameter naming, or navigation mechanism used elsewhere in 
the application, and single it out for in-depth testing. 



2.2.1 Identify all the different entry points that exist for introducing user 
input into the application's processing, including URLs, query string 
parameters, post data, cookies, and other HTTP headers processed by 
the application. 

2.2.2 Examine any customized data transmission or encoding mechanisms 
used by the application, such as a nonstandard query string format. 
Understand whether the data being submitted encapsulates parameter 
names and values, or whether an alternative means of representation 
is being used. 

2.2.3 Identify any out-of-band channels via which user-controllable or other 
third-party data is being introduced into the application's processing. 
An example is a web mail application that processes and renders mes- 
sages received via SMTP. 



2.3.1 Identify each of the different technologies used on the client side, such as 
forms, scripts, cookies, Java applets, ActiveX controls, and Flash objects. 

2.3.2 As far as possible, establish which technologies are being used on the 
server side, including scripting languages, application platforms, and 
interaction with back-end components such as databases and e-mail 
systems. 

2.3.3 Check the HTTP server header returned in application responses, and 
also check for any other software identifiers contained within custom 
HTTP headers or HTML source code comments. Note that in some cases, 
different areas of the application are handled by different back-end 
components, so different banners may be received. 

2.3.4 Run the Httprint tool to fingerprint the web server. 

2.3.5 Review the results of your content-mapping exercises to identify any 
interesting-looking file extensions, directories, or other URL subsequences 



2.2 



Identify Data Entry Points 



2.3 



Identify the Technologies Used 



800 Chapter 21 A Web Application Hacker's Methodology 



that may provide clues about the technologies in use on the server. 
Review the names of any session tokens and other cookies issued. Use 
Google to search for technologies associated with these items. 

2.3.6 Identify any interesting-looking script names and query string parameters 
that may belong to third-party code components. Search for these on 
Google using the inurl : qualifier to find any other applications using 
the same scripts and parameters and that therefore may be using the 
same third-party components. Perform a noninvasive review of these 
sites, because this may uncover additional content and functionality that 
is not explicitly linked on the application you are attacking. 

2.4 Map the Attack Surface 

2.4.1 Try to ascertain the likely internal structure and functionality of the 
server-side application and the mechanisms it uses behind the scenes 
to deliver the behavior that is visible from the client perspective. For 
example, a function to retrieve customer orders is likely to be interacting 
with a database. 

2.4.2 For each item of functionality, identify the kinds of common vulnerabilities 
that are often associated with it. For example, file upload functions may 
be vulnerable to path traversal, inter-user messaging may be vulnerable 
to XSS, and Contact Us functions may be vulnerable to SMTP injection. 
See Chapter 4 for examples of vulnerabilities commonly associated with 
particular functions and technologies. 

2.4.3 Formulate a plan of attack, prioritizing the most interesting-looking 
functionality and the most serious of the potential vulnerabilities associ- 
ated with it. Use your plan to guide the amount of time and effort you 
devote to each of the remaining areas of this methodology. 

3 Test Client-Side Controls 



3.1. Transmission of 
data via client 

Hidden fields 



Cookies 



Preset parameters 



ASP.NET ViewState 



3.2. Client-side input 
controls 



Length limits 



JavaScript validation 



Disabled elements 



3.3. Browser 
Extensions 



Java applets 



ActiveX controls 



] 



Flash objects 



] 



^MverMght^bject^J 



Figure 21-4: Testing client-side controls 



Chapter 21 A Web Application Hacker's Methodology 801 



3.1 Test Transmission of Data Via the Client 

3.1.1 Locate all instances within the application where hidden form fields, 
cookies, and URL parameters are apparently being used to transmit 
data via the client. 

3.1.2 Attempt to determine the purpose that the item plays in the applica- 
tion's logic, based on the context in which it appears and on its name 
and value. 

3.1.3 Modify the item's value in ways that are relevant to its role in the 
application's functionality. Determine whether the application pro- 
cesses arbitrary values submitted in the field and whether this fact 
can be exploited to interfere with the application's logic or subvert 
any security controls. 

3. 1 .4 If the application transmits opaque data via the client, you can attack this 
in various ways. If the item is obfuscated, you may be able to decipher 
the obfuscation algorithm and therefore submit arbitrary data within the 
opaque item. Even if it is securely encrypted, you may be able to replay 
the item in other contexts to interfere with the application's logic. See 
Chapter 5 for more details on these and other attacks. 

3.1.5 If the application uses the ASP.NET viewstate, test to confirm whether 
this can be tampered with or whether it contains any sensitive infor- 
mation. Note that the viewstate may be used differently on different 
application pages. 

3.1.5.1 Use the viewstate analyzer in Burp Suite to confirm whether 
the EnableviewStateMac option has been enabled, meaning 
that the viewstate's contents cannot be modified. 

3.1.5.2 Review the decoded viewstate to identify any sensitive data it 
contains. 

3.1.5.3 Modify one of the decoded parameter values and reencode and 
submit the viewstate. If the application accepts the modified 
value, you should treat the viewstate as an input channel for 
introducing arbitrary data into the application's processing. 
Perform the same testing on the data it contains as you would 
for any other request parameters. 

3.2 Test Client-Side Controls Over User Input 

3.2.1 Identify any cases where client-side controls such as length limits and 
JavaScript checks are used to validate user input before it is submitted 



802 Chapter 21 A Web Application Hacker's Methodology 



to the server. These controls can be bypassed easily, because you can 
send arbitrary requests to the server. For example: 

<form action= " order . asp" onsubmit= " return Validate ( this )" > 
<input maxlength= " 3 " name =" quantity " > 

3.2.2 Test each affected input field in turn by submitting input that would 
ordinarily be blocked by the client-side controls to verify whether these 
are replicated on the server. 

3.2.3 The ability to bypass client-side validation does not necessarily represent 
any vulnerability. Nevertheless, you should review closely what vali- 
dation is being performed. Confirm whether the application is relying 
on the client-side controls to protect itself from malformed input. Also 
confirm whether any exploitable conditions exist that can be triggered 
by such input. 

3.2.4 Review each HTML form to identify any disabled elements, such as 
grayed-out submit buttons. For example: 

<input disabled= " true " name= "product " > 

If you find any, submit these to the server, along with the form's other 
parameters. See whether the parameter has any effect on the server's 
processing that you can leverage in an attack. Alternatively, use an 
automated proxy rule to automatically enable disabled fields, such as 
Burp Proxy's "HTML Modification" rules. 

3.3 Test Browser Extension Components 

5.5.7 Understand the Client Application's Operation 

3.3.1.1 Set up a local intercepting proxy for the client technology under review, 
and monitor all traffic passing between the client and server. If data is 
serialized, use a deserialization tool such as Burp's built-in AMF support 
or the DSer Burp plug-in for Java. 

3.3.1.2 Step through the functionality presented in the client. Determine any 
potentially sensitive or powerful functions, using standard tools within 
the intercepting proxy to replay key requests or modify server responses. 

5.5.2 Decompile the Client 

3.3.2.1 Identify any applets employed by the application. Look for any of the 
following file types being requested via your intercepting proxy: 

■ .class, .jar : Java 

■ . swf .- Flash 

■ .xap : Silverlight 



Chapter 21 A Web Application Hacker's Methodology 805 



You can also look for applet tags within the HTML source code of 
application pages. For example: 

opplet code= " input . class " id= "TheApplet " codebase= " /scripts/ " ></ 
applet> 

3.3.2.2 Review all calls made to the applet's methods from within the invoking 
HTML, and determine whether data returned from the applet is being 
submitted to the server. If this data is opaque (that is, obfuscated or 
encrypted), to modify it you will probably need to decompile the applet 
to obtain its source code. 

3.3.2.3 Download the applet bytecode by entering the URL into your browser, 
and save the file locally. The name of the bytecode file is specified in 
the code attribute of the applet tag. The file will be located in the direc- 
tory specified in the codebase attribute if this is present. Otherwise, it 
will be located in the same directory as the page in which the applet tag 
appears. 

3.3.2.4 Use a suitable tool to decompile the bytecode into source code. For 
example: 

C:\>jad.exe input. class 

Parsing input . class .. . Generating input. j ad 

Here are some suitable tools for decompiling different browser exten- 
sion components: 

■ Java — Jad 

■ Flash — SWFScan, Flasm/ Flare 

■ Silverlight — .NET Reflector 

If the applet is packaged into a JAR, XAP, or SWF file, you can unpack 
it using a standard archive reader such as WinRar or WinZip. 

3.3.2.5 Review the relevant source code (starting with the implementation of 
the method that returns the opaque data) to understand what processing 
is being performed. 

3.3.2.6 Determine whether the applet contains any public methods that can be 
used to perform the relevant obfuscation on arbitrary input. 

3.3.2.7 If it doesn't, modify the applet's source to neutralize any validation it 
performs or to allow you to obfuscate arbitrary input. You can then 
recompile the source into its original file format using the compilation 
tools provided by the vendor. 

5.5.5 Attach a Debugger 

3.3.3.1 For large client-side applications, it is often prohibitively difficult to 
decompile the whole application, modify it, and repackage it without 



804 Chapter 21 A Web Application Hacker's Methodology 



encountering numerous errors. For these applications it is generally 
quicker to attach a runtime debugger to the process. JavaSnoop does this 
very well for Java. Silverlight Spy is a freely available tool that allows 
runtime monitoring of Silverlight clients. 

3.3.3.2 Locate the key functions and values the application employs to drive 
security-related business logic, and place breakpoints when the targeted 
function is called. Modify the arguments or return value as needed to 
affect the security bypass. 

3. 3. 4 Test A ctiveX controls 

3.3.4.1 Identify any ActiveX controls employed by the application. Look for 
any . cab file types being requested via your intercepting proxy, or look 
for object tags within the HTML source code of application pages. For 
example: 

<0BJECT 

classid= "CLSID: 4F87 8398-E58A-11D3-BEE9-00C04FA0D6BA" 
codebase= "https : / /wahh app . com/ scripts /input . cab" 
id= " TheAxControl " > 
</0BJECT> 

3.3.4.2 It is usually possible to subvert any input validation performed within 
an ActiveX control by attaching a debugger to the process and directly 
modifying data being processed or altering the program's execution 
path. See Chapter 5 for more details about this kind of attack. 

3.3.4.3 It is often possible to guess the purpose of different methods that an 
ActiveX control exports based on their names and the parameters 
passed to them. Use the COMRaider tool to enumerate the methods 
exported by the control. Test whether any of these can be manipu- 
lated to affect the control's behavior and defeat any validation tests 
it implements. 

3.3.4.4 If the control's purpose is to gather or verify certain information about 
the client computer, use the Filemon and Regmon tools to monitor the 
information the control gathers. It is often possible to create suitable 
items within the system registry and filesystem to fix the inputs used 
by the control and therefore affect its behavior. 

3.3.4.5 Test any ActiveX controls for vulnerabilities that could be exploited to 
attack other users of the application. You can modify the HTML used 
to invoke a control to pass arbitrary data to its methods and monitor 
the results. Look for methods with dangerous-sounding names, such 
as LaunchExe. You can also use COMRaider to perform some basic fuzz 
testing of ActiveX controls to identify flaws such as buffer overflows. 



Chapter 21 A Web Application Hacker's Methodology 805 



4 Test the Authentication Mechanism 



4.1. Understand the mechanism 



Data attacks 



4.2. Test password 
quality 



4.3. Test for 
username 
enumeration 



4.4. Test for 
password guessing 



Special functions 



4.5. Test account 
recovery 



4.6. Test "remember 
me" 



4.7. Test 
impersonation 
functions 



Credential handling 



4.8. Test username 
uniqueness 



4.9. Test credential 
predictability 



4.10. Check for 
unsafe transmission 



4.11. Check for 
unsafe distribution 



4.12. Check for 
insecure storage 



\7 



Authentication 
logic 



4.13.1. Test for 
fail-open logic 



4.13.2. Test 
multistage 
processes 



4.14. Exploit vulnerabilities 



Figure 21-5: Testing the authentication mechanism 



4.1 Understand the Mechanism 

4.1.1 Establish the authentication technologies in use (for example, forms, 
certificates, or multif actor). 

4.1.2 Locate all the authentication-related functionality (including login, 
registration, account recovery, and so on). 

4.1.3 If the application does not implement an automated self-registration 
mechanism, determine whether any other means exists of obtaining 
several user accounts. 



806 Chapter 21 A Web Application Hacker's Methodology 



4.2 Test Password Quality 

4.2.1 Review the application for any description of the minimum quality rules 
enforced on user passwords. 

4.2.2 Attempt to set various kinds of weak passwords, using any self -registration 
or password change functions to establish the rules actually enforced. 
Try short passwords, alphabetic characters only, single-case characters 
only, dictionary words, and the current username. 

4.2.3 Test for incomplete validation of credentials. Set a strong and complex 
password (for example, 12 characters with mixed-case letters, numerals, 
and typographic characters). Attempt to log in using different varia- 
tions on this password, by removing the last character, by changing a 
character's case, and by removing any special characters. If any of these 
login attempts is successful, continue experimenting systematically to 
identify what validation is actually being performed. 

4.2.4 Having established the minimum password quality rules, and the extent 
of password validation, identify the range of values that a password- 
guessing attack would need to employ to have a good probability of 
success. Attempt to locate any built-in accounts that may not have been 
subject to the standard password complexity requirements. 

4.3 Test for Username Enumeration 

4.3.1 Identify every location within the various authentication functions 
where a username is submitted, including via an on-screen input field, 
a hidden form field, or a cookie. Common locations include the primary 
login, self-registration, password change, logout, and account recovery. 

4.3.2 For each location, submit two requests, containing a valid and an invalid 
username. Review every detail of the server's responses to each pair of 
requests, including the HTTP status code, any redirects, information 
displayed on-screen, any differences hidden in the HTML page source, 
and the time taken for the server to respond. Note that some differences 
may be subtle (for example, the same error message may contain minor 
typographical differences). You can use the history function of your 
intercepting proxy to review all traffic to and from the server. WebScarab 
has a function to compare two responses to quickly highlight any dif- 
ferences between them. 

4.3.3 If you observe any differences between the responses where a valid and 
invalid username is submitted, repeat the test with a different pair of 
values and confirm that a systematic difference exists that can provide 
a basis for automated username enumeration. 



Chapter 21 A Web Application Hacker's Methodology 807 



4.3.4 Check for any other sources of information leakage within the applica- 
tion that may enable you to compile a list of valid usernames. Examples 
are logging functionality, actual listings of registered users, and direct 
mention of names or e-mail addresses in source code comments. 

4.3.5 Locate any subsidiary authentication that accepts a username, and 
determine whether it can be used for username enumeration. Pay 
specific attention to a registration page that allows specification of a 
username. 

4.4 Test Resilience to Password Guessing 

4.4.1 Identify every location within the application where user credentials 
are submitted. The two main instances typically are the main login 
function and the password change function. The latter normally is a 
valid target for password-guessing attacks only if an arbitrary username 
can be supplied. 

4.4.2 At each location, using an account that you control, manually send 
several requests containing the valid username but other invalid 
credentials. Monitor the application's responses to identify any differ- 
ences. After about 10 failed logins, if the application has not returned 
a message about account lockout, submit a request containing valid 
credentials. If this request succeeds, an account lockout policy prob- 
ably is not in force. 

4.4.3 If you do not control any accounts, attempt to enumerate or guess a 
valid username, and make several invalid requests using this guess, 
monitoring for any error messages about account lockout. Of course, 
you should be aware that this test may have the effect of suspending or 
disabling an account belonging to another user. 

4.5 Test Any Account Recovery Function 

4.5.1 Identify whether the application contains any facility for users to regain 
control of their account if they have forgotten their credentials. This 
is often indicated by a Forgot Your Password link near the main login 
function. 

4.5.2 Establish how the account recovery function works by doing a complete 
walk-through of the recovery process using an account you control. 

4.5.3 If the function uses a challenge such as a secret question, determine 
whether users can set or select their own challenge during registration. 
If so, use a list of enumerated or common usernames to harvest a list of 
challenges, and review this for any that appear to be easily guessable. 



808 Chapter 21 A Web Application Hacker's Methodology 



4.5.4 If the function uses a password hint, perform the same exercise to har- 
vest a list of password hints, and identify any that appear to be easily 
guessable. 

4.5.5 Perform the same tests on any account-recovery challenges that you per- 
formed at the main login function to assess vulnerability to automated 
guessing attacks. 

4.5.6 If the function involves sending an e-mail to the user to complete the 
recovery process, look for any weaknesses that may enable you to take 
control of other users' accounts. Determine whether it is possible to 
control the address to which the e-mail is sent. If the message contains 
a unique recovery URL, obtain a number of messages using an e-mail 
address you control, and attempt to identify any patterns that may enable 
you to predict the URLs issued to other users. Apply the methodology 
described in step 5.3 to identify any predictable sequences. 

4.6 Test Any Remember Me Function 

4.6.1 If the main login function or its supporting logic contains a Remember 
Me function, activate this and review its effects. If this function allows the 
user to log in on subsequent occasions without entering any credentials, 
you should review it closely for any vulnerabilities. 

4.6.2 Closely inspect all persistent cookies that are set when the Remember Me 
function is activated. Look for any data that identifies the user explicitly 
or appears to contain some predictable identifier of the user. 

4.6.3 Even where the data stored appears to be heavily encoded or obfuscated, 
review this closely, and compare the results of remembering several very 
similar usernames and/ or passwords to identify any opportunities to 
reverse-engineer the original data. Apply the methodology described 
in step 5.2 to identify any meaningful data. 

4.6.4 Depending on your results, modify the contents of your cookie in suit- 
able ways in an attempt to masquerade as other users of the application. 

4.7 Test Any Impersonation Function 

4.7.1 If the application contains any explicit functionality that allows one 
user to impersonate another, review this closely for any vulnerabilities 
that may enable you to impersonate arbitrary users without proper 
authorization. 

4.7.2 Look for any user-supplied data that is used to determine the target 
of the impersonation. Attempt to manipulate this to impersonate 



Chapter 21 A Web Application Hacker's Methodology 809 



other users, particularly administrative users, which may enable you 
escalate privileges. 

4.7.3 If you perform any automated password-guessing attacks against other 
user accounts, look for any accounts that appear to have more than one 
valid password, or multiple accounts that appear to have the same pass- 
word. This may indicate the presence of a backdoor password, which 
administrators can use to access the application as any user. 

4.8 Test Username Uniqueness 

4.8.1 If the application has a self-registration function that lets you specify 
a desired username, attempt to register the same username twice with 
different passwords. 

4.8.2 If the application blocks the second registration attempt, you can exploit 
this behavior to enumerate registered usernames. 

4.8.3 If the application registers both accounts, probe further to determine its 
behavior when a collision of username and password occurs. Attempt 
to change the password of one of the accounts to match that of the 
other. Also, attempt to register two accounts with identical usernames 
and passwords. 

4.8.4 If the application alerts you or generates an error when a collision of 
username and password occurs, you can probably exploit this to perform 
an automated guessing attack to discover another user's password. Target 
an enumerated or guessed username, and attempt to create accounts 
that have this username and different passwords. When the applica- 
tion rejects a specific password, you have probably found the existing 
password for the targeted account. 

4.8.5 If the application appears to tolerate a collision of username and pass- 
word without an error, log in using the colliding credentials. Determine 
what happens and whether the application's behavior can be leveraged 
to gain unauthorized access to other users' accounts. 

4.9 Test Predictability of Autogenerated Credentials 

4.9.1 If the application automatically generates usernames or passwords, try 
to obtain several values in quick succession and identify any detectable 
sequences or patterns. 

4.9.2 If usernames are generated in a predictable way, extrapolate backwards 
to obtain a list of possible valid usernames. You can use this as the basis 
for automated password-guessing and other attacks. 



810 Chapter 21 A Web Application Hacker's Methodology 



4.9.3 If passwords are generated in a predictable way, extrapolate the pattern 
to obtain a list of possible passwords issued to other application users. 
This can be combined with any lists of usernames you obtain to perform 
a password-guessing attack. 

4.10 Check for Unsafe Transmission of Credentials 

4.10.1 Walk through all authentication-related functions that involve trans- 
mission of credentials, including the main login, account registration, 
password change, and any page that allows viewing or updating of 
user profile information. Monitor all traffic passing in both directions 
between the client and server using your intercepting proxy. 

4.10.2 Identify every case in which the credentials are transmitted in either 
direction. You can set interception rules in your proxy to flag messages 
containing specific strings. 

4.10.3 If credentials are ever transmitted in the URL query string, these are 
potentially vulnerable to disclosure in the browser history, on-screen, 
in server logs, and in the Referer header when third-party links are 
followed. 

4.10.4 If credentials are ever stored in a cookie, these are potentially vulnerable 
to disclosure via XSS attacks or local privacy attacks. 

4.10.5 If credentials are ever transmitted from the server to the client, these 
may be compromised via any vulnerabilities in session management or 
access controls, or in an XSS attack. 

4.10.6 If credentials are ever transmitted over an unencrypted connection, these 
are vulnerable to interception by an eavesdropper. 

4.10.7 If credentials are submitted using HTTPS but the login form itself is 
loaded using HTTP, the application is vulnerable to a man-in-the-middle 
attack that may be used to capture credentials. 

4.1 1 Check for Unsafe Distribution of Credentials 

4.11.1 If accounts are created via some out-of-band channel, or the applica- 
tion has a self-registration function that does not itself determine all of 
a user's initial credentials, establish the means by which credentials are 
distributed to new users. Common methods include sending a message 
to an e-mail or postal address. 



Chapter 21 A Web Application Hacker's Methodology 811 



4.11.2 If the application generates account activation URLs that are distributed 
out-of-band, try to register several new accounts in close succession, 
and identify any sequence in the URLs you receive. If a pattern can 
be determined, try to predict the URLs sent to recent and forthcom- 
ing users, and attempt to use these URLs to take ownership of their 
accounts. 

4. 1 1 .3 Try to reuse a single activation URL multiple times, and see if the appli- 
cation allows this. If it doesn't, try locking out the target account before 
reusing the URL, and see if the URL still works. Determine whether this 
enables you to set a new password on an active account. 

4.12 Test for Insecure Storage 

4.12.1 If you gain access to hashed passwords, check for accounts that share 
the same hashed password value. Try to log in with common passwords 
for the most common hashed value. 

4.12.2 Use an offline rainbow table for the hashing algorithm in question to 
recover the cleartext value. 



4.13 Test for Logic Flaws 

4. 13. 1 Test for Fail-Open Conditions 

4.13.1.1 For each function in which the application checks a user 's credentials, 
including the login and password change functions, walk through the 
process in the normal way, using an account you control. Note every 
request parameter submitted to the application. 

4.13.1.2 Repeat the process numerous times, modifying each parameter in turn 
in various unexpected ways designed to interfere with the application's 
logic. For each parameter, include the following changes: 

■ Submit an empty string as the value. 

■ Remove the name/value pair. 

■ Submit very long and very short values. 

■ Submit strings instead of numbers, and vice versa. 

■ Submit the same named parameter multiple times, with the same 
and different values. 



812 Chapter 21 A Web Application Hacker's Methodology 



4.13.1.3 Review closely the application's responses to the preceding requests. If 
any unexpected divergences from the base case occur, feed this obser- 
vation back into your framing of further test cases. If one modification 
causes a change in behavior, try to combine this with other changes to 
push the application's logic to its limits. 

4.13.2 Test Any Multistage Mechanisms 

4.13.2.1 If any authentication-related function involves submitting credentials 
in a series of different requests, identify the apparent purpose of each 
distinct stage, and note the parameters submitted at each stage. 

4.13.2.2 Repeat the process numerous times, modifying the sequence of requests 
in ways designed to interfere with the application's logic, including 
the following tests: 

■ Proceed through all stages, but in a different sequence than the one 
intended. 

■ Proceed directly to each stage in turn, and continue the normal 
sequence from there. 

■ Proceed through the normal sequence several times, skipping each 
stage in turn, and continuing the normal sequence from the next stage. 

■ On the basis of your observations and the apparent purpose of each 
stage of the mechanism, try to think of further ways to modify the 
sequence and to access the different stages that the developers may 
not have anticipated. 

4.13.2.3 Determine whether any single piece of information (such as the user- 
name) is submitted at more than one stage, either because it is captured 
more than once from the user or because it is transmitted via the client 
in a hidden form field, cookie, or preset query string parameter. If so, try 
submitting different values at different stages (both valid and invalid) 
and observing the effect. Try to determine whether the submitted item 
is sometimes superfluous, or is validated at one stage and then trusted 
subsequently, or is validated at different stages against different checks. 
Try to exploit the application's behavior to gain unauthorized access 
or reduce the effectiveness of the controls imposed by the mechanism. 

4.13.2.4 Look for any data that is transmitted via the client that has not been 
captured from the user at any point. If hidden parameters are used 



Chapter 21 A Web Application Hacker's Methodology 815 



to track the state of the process across successive stages, it may be 
possible to interfere with the application's logic by modifying these 
parameters in crafted ways. 

4.13.2.5 If any part of the process involves the application's presenting a ran- 
domly varying challenge, test for two common defects: 

■ If a parameter specifying the challenge is submitted along with the 
user's response, determine whether you can effectively choose your 
own challenge by modifying this value. 

■ Try proceeding as far as the varying challenge several times with 
the same username, and determine whether a different challenge 
is presented. If it is, you can effectively choose your own chal- 
lenge by proceeding to this stage repeatedly until your desired 
challenge is presented. 



4.14 Exploit Any Vulnerabilities to Gain 
Unauthorized Access 

4.14.1 Review any vulnerabilities you have identified within the various authen- 
tication functions, and identify any that you can leverage to achieve 
your objectives in attacking the application. This typically involves 
attempting to authenticate as a different user — if possible, a user with 
administrative privileges. 

4.14.2 Before mounting any kind of automated attack, note any account 
lockout defenses you have identified. For example, when performing 
username enumeration against a login function, submit a common 
password with each request rather than a completely arbitrary value 
so as not to waste a failed login attempt on every username discovered. 
Similarly, perform any password-guessing attacks on a breadth-first, 
not depth-first, basis. Start your word list with the most common weak 
passwords, and proceed through this list, trying each item against 
every enumerated username. 

4.14.3 Take account of the password quality rules and the completeness of 
password validation when constructing word lists to use in any password- 
guessing attack to avoid impossible or superfluous test cases. 

4.14.4 Use the techniques described in Chapter 14 to automate as much 
work as possible and maximize the speed and effectiveness of your 
attacks. 



814 Chapter 21 A Web Application Hacker's Methodology 



5 Test the Session Management Mechanism 



5.1. Understand the mechanism 



Token generation 



Token handling 



5.2. Test for meaning 



^^^sUo^redictabilit^ 



5.4. Check for insecure transmission 



5.5. Check for disclosure in logs 



5.6. Test mapping of tokens to sessions 



5.7. Test session termination 



5.8. Test for session fixation 



5.9. Check for CSRF 



5.10. Check cookie scope 



Figure 21-6: Testing the session management mechanism 



5.1 Understand the Mechanism 

5.1.1 Analyze the mechanism used to manage sessions and state. Establish 
whether the application uses session tokens or some other method of 
handling the series of requests received from each user. Note that some 
authentication technologies (such as HTTP authentication) may not 
require a full session mechanism to reidentify users post-authentication. 
Also, some applications use a sessionless state mechanism in which all 
state information is transmitted via the client, usually in an encrypted 
or obfuscated form. 

5.1.2 If the application uses session tokens, confirm precisely which pieces 
of data are actually used to reidentify users. Items that may be used to 
transmit tokens include HTTP cookies, query string parameters, and 
hidden form fields. Several different pieces of data may be used collec- 
tively to reidentify the user, and different items may be used by different 
back-end components. Often, items that look like session tokens may 
not actually be employed as such by the application, such as the default 
cookie generated by the web server. 



Chapter 21 A Web Application Hacker's Methodology 815 



5.1.3 To verify which items are actually being employed as session tokens, 
find a page or function that is certainly session-dependent (such as a 
user-specific My Details page). Then make several requests for it, sys- 
tematically removing each item you suspect is being used as a session 
token. If removing an item stops the session-dependent page from being 
returned, this may confirm that the item is a session token. Burp Repeater 
is a useful tool for performing these tests. 

5.1.4 Having established which items of data are actually being used to reiden- 
tify users, for each token confirm whether it is being validated in its 
entirety, or whether some subcomponents of the token are ignored. 
Change the token's value 1 byte at a time, and check whether the modi- 
fied value is still accepted. If you find that certain portions of the token 
are not actually used to maintain session state, you can exclude these 
from further analysis. 

5.2 Test Tokens for Meaning 

5.2.1 Log in as several different users at different times, and record the tokens 
received from the server. If self -registration is available and you can choose 
your username, log in with a series of similar usernames that have small 
variations, such as A, AA, AAA, AAAA, AAAB, AAAC, AABA, and so 
on. If other user-specific data is submitted at the login or is stored in user 
profiles (such as an e-mail address), perform a similar exercise to modify 
that data systematically and capture the resulting tokens. 

5.2.2 Analyze the tokens you receive for any correlations that appear to be 
related to the username and other user-controllable data. 

5.2.3 Analyze the tokens for any detectable encoding or obfuscation. Look 
for a correlation between the length of the username and the length of 
the token, which strongly indicates that some kind of obfuscation or 
encoding is in use. Where the username contains a sequence of the same 
character, look for a corresponding character sequence in the token, 
which may indicate the use of XOR obfuscation. Look for sequences in 
the token that contain only hexadecimal characters, which may indicate 
hexadecimal encoding of an ASCII string or other information. Look for 
sequences ending in an equals sign and/ or containing only the other 
valid Base64 characters: a to z, A to Z, to 9, +, and /. 

5.2.4 If you can identify any meaningful data within your sample of session 
tokens, consider whether this is sufficient to mount an attack that attempts 
to guess the tokens recently issued to other application users. Find a 
page of the application that is session-dependent, and use the techniques 



816 Chapter 21 A Web Application Hacker's Methodology 



described in Chapter 14 to automate the task of generating and testing 
possible tokens. 

5.3 Test Tokens for Predictability 

5.3.1 Generate and capture a large number of session tokens in quick succes- 
sion, using a request that causes the server to return a new token (for 
example, a successful login request). 

5.3.2 Attempt to identify any patterns within your sample of tokens. In all 
cases you should use Burp Sequencer, as described in Chapter 7, to 
perform detailed statistical tests of the randomness properties of the 
application's tokens. Depending on the results, it may also be useful to 
perform the following manual analysis: 

■ Apply your understanding of which tokens and subsequences the 
application actually uses to reidentify users. Ignore any data that is 
not used in this way, even if it varies between samples. 

■ If it is unclear what type of data is contained in the token, or in any 
individual component of it, try applying various decodings (for exam- 
ple, Base64) to see if any more meaningful data emerges. It may be 
necessary to apply several decodings in sequence. 

■ Try to identify any patterns in the sequences of values contained in 
each decoded token or component. Calculate the differences between 
successive values. Even if these appear to be chaotic, there may be a 
fixed set of observed differences, which narrows down the scope of 
any brute-force attack considerably. 

■ Obtain a similar sample of tokens after waiting for a few minutes, 
and repeat the same analysis. Try to detect whether any of the tokens' 
content is time-dependent. 

5.3.3 If you identify any patterns, capture a second sample of tokens using 
a different IP address and a different username. This will help you 
identify whether the same pattern is detected and whether tokens 
received in the first exercise could be extrapolated to guess tokens 
received in the second. 

5.3.4 If you can identify any exploitable sequences or time dependencies, 
consider whether this is sufficient to mount an attack that attempts 
to guess the tokens recently issued to other application users. Use the 
techniques described in Chapter 14 to automate the task of generating 
and testing possible tokens. Except in the simplest kind of sequences, 
it is likely that your attack will need to involve a customized script 
of some kind. 



Chapter 21 A Web Application Hacker's Methodology 817 



5.3.5 If the session ID appears to be custom-written, use the "bit flipper" 
payload source in Burp Intruder to sequentially modify each bit in the 
session token in turn. Grep for a string in the response that indicates 
whether modifying the token has not resulted in an invalid session, and 
whether the session belongs to a different user. 

5.4 Check for Insecure Transmission of Tokens 

5.4.1 Walk through the application as normal, starting with unauthenticated 
content at the start URL, proceeding through the login process, and 
then going through all the application's functionality. Make a note 
of every occasion on which a new session token is issued, and which 
portions of your communications use HTTP and which use HTTPS. 
You can use the logging function of your intercepting proxy to record 
this information. 

5.4.2 If HTTP cookies are being used as the transmission mechanism for ses- 
sion tokens, verify whether the secure flag is set, preventing them from 
ever being transmitted over HTTP connections. 

5.4.3 Determine whether, in the normal use of the application, session tokens 
are ever transmitted over an HTTP connection. If so, they are vulnerable 
to interception. 

5.4.4 In cases where the application uses HTTP for unauthenticated areas 
and switches to HTTPS for the login and /or authenticated areas of 
the application, verify whether a new token is issued for the HTTPS 
portion of the communications, or whether a token issued during the 
HTTP stage remains active when the application switches to HTTPS. 
If a token issued during the HTTP stage remains active, the token is 
vulnerable to interception. 

5.4.5 If the HTTPS area of the application contains any links to HTTP URLs, 
follow these and verify whether the session token is submitted. If it is, 
determine whether it continues to be valid or is immediately terminated 
by the server. 

5.5 Check for Disclosure of Tokens in Logs 

5.5.1 If your application mapping exercises identified any logging, monitoring, 
or diagnostic functionality, review these functions closely to determine 
whether any session tokens are disclosed within them. Confirm who is 
normally authorized to access these functions. If they are intended for 
administrators only, determine whether any other vulnerabilities exist 
that could enable a lower-privileged user to access them. 



818 Chapter 21 A Web Application Hacker's Methodology 



5.5.2 Identify any instances where session tokens are transmitted within the 
URL. It may be that tokens are generally transmitted in a more secure 
manner, but that developers have used the URL in specific cases to 
work around a particular problem. If so, these may be transmitted in 
the Ref erer header when users follow any off-site links. Check for any 
functionality that enables you to inject arbitrary off-site links into pages 
viewed by other users. 

5.5.3 If you find any way to gather valid session tokens issued to other users, 
look for a way to test each token to determine whether it belongs to an 
administrative user (for example, by attempting to access a privileged 
function using the token). 

5.6 Check Mapping of Tokens to Sessions 

5.6.1 Log in to the application twice using the same user account, either from 
different browser processes or from different computers. Determine 
whether both sessions remain active concurrently. If they do, the appli- 
cation supports concurrent sessions, enabling an attacker who has 
compromised another user's credentials to use these without risk of 
detection. 

5.6.2 Log in and log out several times using the same user account, either from 
different browser processes or from different computers. Determine 
whether a new session token is issued each time, or whether the same 
token is issued every time the same account logs in. If the latter occurs, 
the application is not really employing proper session tokens, but is 
using unique persistent strings to reidentify each user. In this situation, 
there is no way to protect against concurrent logins or properly enforce 
session timeout. 

5.6.3 If tokens appear to contain any structure and meaning, attempt to separate 
out components that may identify the user from those that appear to be 
inscrutable. Try to modify any user-related components of the token so 
that they refer to other known users of the application. Verify whether 
the application accepts the resulting token and whether it enables you 
to masquerade as that user. See Chapter 7 for examples of this kind of 
subtle vulnerability. 

5.7 Test Session Termination 

5.7.1 When testing for session timeout and logout flaws, focus solely on the 
server's handling of sessions and tokens, rather than any events that occur 
on the client. In terms of session termination, nothing much depends on 
what happens to the token within the client browser. 



Chapter 21 A Web Application Hacker's Methodology 819 



5.7.2 Check whether session expiration is implemented on the server: 

■ Log in to the application to obtain a valid session token. 

■ Wait for a period without using this token, and then submit a request 
for a protected page (such as My Details) using the token. 

■ If the page is displayed normally, the token is still active. 

■ Use trial and error to determine how long any session expiration 
timeout is, or whether a token can still be used days after the previous 
request that used it. Burp Intruder can be configured to increment 
the time interval between successive requests to automate this task. 

5.7.3 Check whether a logout function exists. If it does, test whether it effec- 
tively invalidates the user's session on the server. After logging out, 
attempt to reuse the old token, and determine whether it is still valid by 
requesting a protected page using the token. If the session is still active, 
users remain vulnerable to some session hijacking attacks even after 
they have "logged out." You can use Burp Repeater to keep sending a 
specific request from the proxy history to see whether the application 
responds differently after you log out. 

5.8 Check for Session Fixation 

5.8.1 If the application issues session tokens to unauthenticated users, obtain 
a token and perform a login. If the application does not issue a fresh 
token following a successful login, it is vulnerable to session fixation. 

5.8.2 Even if the application does not issue session tokens to unauthenticated 
users, obtain a token by logging in, and then return to the login page. If 
the application is willing to return this page even though you are already 
authenticated, submit another login as a different user using the same 
token. If the application does not issue a fresh token after the second 
login, it is vulnerable to session fixation. 

5.8.3 Identify the format of session tokens that the application uses. Modify 
your token to an invented value that is validly formed, and attempt to 
log in. If the application allows you to create an authenticated session 
using an invented token, it is vulnerable to session fixation. 

5.8.4 If the application does not support login, but processes sensitive user 
information (such as personal and payment details) and allows this to 
be displayed after submission (such as on a Verify My Order page), 
carry out the preceding three tests in relation to the pages displaying 
sensitive data. If a token set during anonymous usage of the application 
can later be used to retrieve sensitive user information, the application 
is vulnerable to session fixation. 



820 Chapter 21 A Web Application Hacker's Methodology 



5.9 Check for CSRF 

5.9.1 If the application relies solely on HTTP cookies as its method of trans- 
mitting session tokens, it may be vulnerable to cross-site request forgery 
attacks. 

5.9.2 Review the application's key functionality, and identify the specific 
requests that are used to perform sensitive actions. If an attacker can 
fully determine in advance parameters for any of these requests (that 
is, they do not contain any session tokens, unpredictable data, or other 
secrets), the application is almost certainly vulnerable. 

5.9.3 Create an HTML page that will issue the desired request without any 
user interaction. For get requests, you can place an <img> tag with the 
src parameter set to the vulnerable URL. For post requests, you can 
create a form that contains hidden fields for all the relevant parameters 
required for the attack and that has its target set to the vulnerable 
URL. You can use JavaScript to autosubmit the form as soon as the 
page loads. While logged in to the application, use the same browser 
to load your HTML page. Verify that the desired action is carried out 
within the application. 

5.9.4 If the application uses additional tokens within requests in an attempt to 
prevent CSRF attacks, test the robustness of these in the same manner as 
for session tokens. Also test whether the application is vulnerable to UI 
redress attacks, in order to defeat the anti-CSRF defenses (see Chapter 13 
for more details). 

5.10 Check Cookie Scope 

5.10.1 If the application uses HTTP cookies to transmit session tokens (or 
any other sensitive data), review the relevant Set-Cookie headers, and 
check for any domain or path attributes used to control the scope of the 
cookies. 

5.10.2 If the application explicitly liberalizes its cookies' scope to a parent 
domain or parent directory, it may be leaving itself vulnerable to attacks 
via other web applications that are hosted within the parent domain 
or directory. 

5.10.3 If the application sets its cookies' domain scope to its own domain 
name (or does not specify a domain attribute), it may still be exposed 
to attacks via any applications hosted on subdomains. This is a conse- 
quence of how cookie scoping works. It cannot be avoided other than 
by not hosting any other applications on a subdomain of a security- 
sensitive application. 



Chapter 21 A Web Application Hacker's Methodology 821 



5.10.4 Determine any reliance on segregation by path, such as /site/main and 
/site/ demo, which can be subverted in the event of a cross-site scripting 
attack. 

5.10.5 Identify all the possible domain names and paths that will receive the 
cookies that the application issues. Establish whether any other web 
applications are accessible via these domain names or paths that you 
may be able to leverage to capture the cookies issued to users of the 
target application. 

6 Test Access Controls 



6.1. Understand the requirements 



6.4. Test tor 
insecure methods 



6.2. Test with 
multiple accounts 



6.3. Test with 
limited access 



Figure 21-7: Testing access controls 

6.1 Understand the Access Control Requirements 



6.1.1 



6.1.2 



6.1.3 



Based on the core functionality implemented within the application, 
understand the broad requirements for access control in terms of verti- 
cal segregation (different levels of users have access to different types 
of functionality) and horizontal segregation (users at the same privilege 
level have access to different subsets of data). Often, both types of seg- 
regation are present. For example, ordinary users may be able to access 
their own data, while administrators can access everyone's data. 

Review your application mapping results to identify the areas of func- 
tionality and types of data resources that represent the most fruitful 
targets for privilege escalation attacks. 

To perform the most effective testing for access control vulnerabilities, 
you should ideally obtain a number of different accounts with different 
vertical and horizontal privileges. If self-registration is possible, you can 
probably obtain the latter directly from the application. To obtain the 
former, you will probably need the cooperation of the application owner 
(or need to exploit some vulnerability to gain access to a high-privileged 
account). The availability of different kinds of accounts will affect the 
types of testing you can perform, as described next. 



822 Chapter 21 A Web Application Hacker's Methodology 



6.2 Test with Multiple Accounts 

6.2.1 If the application enforces vertical privilege segregation, first use a 
powerful account to locate all the functionality it can access. Then 
use a less-privileged account and attempt to access each item of this 
functionality. 

6.2.1.1 Using Burp, browse all the application's content within one user 
context. 

6.2.1.2 Review the contents of Burp's site map to ensure you have 
identified all the functionality you want to test. Then, log out 
of the application and log back in using a different user context. 
Use the context menu to select the "compare site maps" feature 
to determine which high-privileged requests may be accessible to 
the lower-privileged user. See Chapter 8 for more details on 
this technique. 

6.2.2 If the application enforces horizontal privilege segregation, perform 
the equivalent test using two different accounts at the same privilege 
level, attempting to use one account to access data belonging to the 
other account. This typically involves replacing an identifier (such as 
a document ID) within a request to specify a resource belonging to the 
other user. 

6.2.3 Perform manual checking of key access control logic. 

6.2.3.1 For each user privilege, review resources available to a user. 
Attempt to access those resources from an unauthorized user 
account by replaying the request using the unauthorized user's 
session token. 

6.2.4 When you perform any kind of access control test, be sure to test every step 
of multistage functions individually to confirm whether access controls 
have been properly implemented at each stage, or whether the application 
assumes that users who access a later stage must have passed security 
checks implemented at the earlier stages. For example, if an administrative 
page containing a form is properly protected, check whether the actual 
form submission is also subjected to proper access controls. 

6.3 Test with Limited Access 

6.3.1 If you do not have prior access to accounts at different privilege levels, or 
to multiple accounts with access to different data, testing for broken access 
controls is not quite as straightforward. Many common vulnerabilities will 
be much harder to locate, because you do not know the names of the URLs, 
identifiers, and parameters that are needed to exploit the weaknesses. 



Chapter 21 A Web Application Hacker's Methodology 825 



6.3.2 In your application mapping exercises that use a low-privileged account, 
you may have identified the URLs for privileged functions such as 
administrative interfaces. If these are not adequately protected, you will 
probably already know about this. 

6.3.3 Decompile all compiled clients that are present, and extract any refer- 
ences to server-side functionality. 

6.3.4 Most data that is subject to horizontal access controls is accessed using 
an identifier, such as an account number or order reference. To test 
whether access controls are effective using only a single account, you 
must try to guess or discover the identifiers associated with other users' 
data. If possible, generate a series of identifiers in quick succession 
(for example, by creating several new orders). Attempt to identify any 
patterns that may enable you to predict the identifiers issued to other 
users. If there is no way to generate new identifiers, you are probably 
restricted to analyzing those you already have and guessing on that 
basis. 

6.3.5 If you find a way to predict the identifiers issued to other users, use the 
techniques described in Chapter 14 to mount an automated attack to 
harvest interesting data belonging to other users. Use the Extract Grep 
function in Burp Intruder to capture the relevant information from within 
the application's responses. 

6.4 Test for Insecure Access Control Methods 

6.4.1 Some applications implement access controls based on request 
parameters in an inherently unsafe way. Look for parameters such 
as edit=f alse or access=read in any key requests, and modify these 
in line with their apparent role to try to interfere with the application's 
access control logic. 

6.4.2 Some applications base access control decisions on the HTTP Ref erer 
header. For example, an application may properly control access to 
/admin . j sp and accept any request showing this as its Ref erer. To test 
for this behavior, attempt to perform some privileged actions to which 
you are authorized, and submit a missing or modified Ref erer header. 
If this change causes the application to block your request, it may be 
using the Ref erer header in an unsafe way. Try performing the same 
action as an unauthorized user, but supply the original Ref erer header 
and see whether the action succeeds. 

6.4.3 If head is an allowed method on the site, test for insecure container- 
managed access control to URLs. Make a request using the head method 
to determine whether the application permits it. 



824 Chapter 21 A Web Application Hacker's Methodology 



7 Test for Input-Based Vulnerabilities 



Many important categories of vulnerabilities are triggered by unexpected user 
input and can appear anywhere within the application. An effective way to 
probe the application for these vulnerabilities is to fuzz every parameter to 
every request with a set of attack strings. 



7.1. Fuzz all request parameters 






Z 








r 








Z 








Z 








Z 








z 


7.2. SQL 
injection 




7.3. XSS and 
response 
injection 




7.4. OS 
command 
injection 




7.5. Path 
traversal 




7.6. Script 
injection 




7.7. File 
inclusion 



Figure 21-8: Testing for input-based vulnerabilities 



7.1 Fuzz All Request Parameters 

7.1.1 Review the results of your application mapping exercises and identify 
every distinct client request that submits parameters that the server-side 
application processes. Relevant parameters include items within the URL 
query string, parameters in the request body, and HTTP cookies. Also 
include any other items of user input that have been observed to have an 
effect on the application's behavior, such as the Ref erer or user-Agent 
headers. 

7.1.2 To fuzz the parameters, you can use your own scripts or a ready-made 
fuzzing tool. For example, to use Burp Intruder, load each request in 
turn into the tool. An easy way to do this is to intercept a request in Burp 
Proxy and select the Send to Intruder action, or right-click an item in the 
Burp Proxy history and select this option. Using this option configures 
Burp Intruder with the contents of the request, along with the correct 
target host and port. It also automatically marks the values of all request 
parameters as payload positions, ready for fuzzing. 

7.1.3 Using the payloads tab, configure a suitable set of attack payloads to 
probe for vulnerabilities within the application. You can enter payloads 
manually, load them from a file, or select one of the preset payload lists. 
Fuzzing every request parameter within the application typically entails 
issuing a large number of requests and reviewing the results for anomalies. 
If your set of attack strings is too large, this can be counterproductive 



Chapter 21 A Web Application Hacker's Methodology 825 



and generate a prohibitively large amount of output for you to review. 
Hence, a sensible approach is to target a range of common vulnerabili- 
ties that can often be easily detected in anomalous responses to specific 
crafted inputs and that often manifest themselves anywhere within 
the application rather than within specific types of functionality. Here 
is a suitable set of payloads that you can use to test for some common 
categories of vulnerabilities: 

SQL Injection 



1 ; waitfor delay '0:30:0'-- 
1; waitfor delay '0:30:0'-- 

XSS and Header Injection 

xsstest 

" ><script>alert ( ' xss ' ) </ script > 

OS Command Injection 

| | ping -i 30 127.0.0.1 ; x ]| ping -n 30 127.0.0.1 & 

| ping -i 30 127 .0.0.1 | 

| ping -n 30 127 .0.0.1 | 
& ping -i 30 127.0.0.1 & 
& ping -n 30 127.0.0.1 & 

; ping 127.0.0.1 ; 

%0a ping -i 30 127.0.0.1 %0a 

' ping 127 .0.0.1 ' 

Path Traversal 

../../../../../../../../../.. /etc/passwd 
../../../../../../../../../.. /boot . ini 
..\..\..\..\..\..\..\..\..\.. \etc\passwd 
. . \ . . \ . . \ . . \ . . \ . . \ . . \ . . \ . . \ . . \boot . ini 

Script Injection 

;echo 111111 

echo 111111 

response .write 111111 

: response . write 111111 

File Inclusion 

http://<your server name>/ 

http : / /<nonexistent IP address>/ 

7. 1 .4 All the preceding payloads are shown in their literal form. The characters 
?, ,• , &, +, =, and space need to be URL-encoded because they have special 



826 Chapter 21 A Web Application Hacker's Methodology 



meaning within HTTP requests. By default, Burp Intruder performs the 
necessary encoding of these characters, so ensure that this option has not 
been disabled. (To restore all options to their defaults following earlier 
customization, select Burp *~ Restore Defaults.) 

7.1.5 In the Grep function of Burp Intruder, configure a suitable set of strings 
to flag some common error messages within responses. For example: 

error 

exception 

illegal 

invalid 

fail 

stack 

access 

directory 

file 

not found 
varchar 
ODBC 
SQL 

SELECT 
111111 

Note that the string mill is included to test for successful script injec- 
tion attacks. The payloads in step 7.1.3 involve writing this value into 
the server's response. 

7.1.6 Also select the Payload Grep option to flag responses that contain the 
payload itself, indicating a potential XSS or header injection vulnerability. 

7.1.7 Set up a web server or netcat listener on the host you specified in the 
first file inclusion payload. This helps you monitor for connection 
attempts received from the server resulting from a successful remote 
file inclusion attack. 

7.1 .8 Launch the attack. When it has completed, review the results for anoma- 
lous responses indicating the presence of vulnerabilities. Check for 
divergences in the HTTP status code, the response length, the response 
time, the appearance of your configured expressions, and the appearance 
of the payload itself. You can click each column heading in the results 
table to sort the results by the values in that column (and Shift-click 
to reverse-sort the results). This enables you to quickly identify any 
anomalies that stand out from the other results. 

7.1.9 For each potential vulnerability indicated by the results of your fuzz test- 
ing, refer to the following sections of this methodology. They describe 
the detailed steps you should take in relation to each category of problem 
to verify the existence of a vulnerability and successfully exploit it. 



Chapter 21 A Web Application Hacker's Methodology 827 



7.1.10 After you have configured Burp Intruder to perform a fuzz test of a single 
request, you can quickly repeat the same test on other requests within 
the application. Simply select each target request within Burp Proxy and 
choose the Send to Intruder option. Then immediately launch the attack 
within Intruder using the existing attack configuration. In this way, you 
can launch a large number of tests simultaneously in separate windows 
and manually review the results as each test completes its work. 

7.1.11 If your mapping exercises identified any out-of-band input channels 
whereby user-controllable input can be introduced into the application's 
processing, you should perform a similar fuzzing exercise on these input 
channels. Submit various crafted data designed to trigger common vul- 
nerabilities when processed within the web application. Depending on 
the nature of the input channel, you may need to create a custom script 
or other harness for this purpose. 

7.1.12 In addition to your own fuzzing of application requests, if you have access 
to an automated web application vulnerability scanner, you should run 
it against the target application to provide a basis for comparison with 
your own findings. 

7.2 Test for SQL Injection 

7.2.1 If the SQL attack strings listed in step 7.1.3 result in any anomalous 
responses, probe the application's handling of the relevant parameter 
manually to determine whether a SQL injection vulnerability is present. 

7.2.2 If any database error messages were returned, investigate their meaning. 
Use the section "SQL Syntax and Error Reference" in Chapter 9 to help 
interpret error messages on some common database platforms. 

7.2.3 If submitting a single quotation mark in the parameter causes an error 
or other anomalous behavior, submit two single quotation marks. If this 
input causes the error or anomalous behavior to disappear, the applica- 
tion is probably vulnerable to SQL injection. 

7.2.4 Try using common SQL string concatenator functions to construct a string 
that is equivalent to some benign input. If this causes the same response 
as the original benign input, the application is probably vulnerable. For 
example, if the original input is the expression foo, you can perform 
this test using the following items (in the third example, note the space 
between the two quotes): 

' | | 'FOO 
' + ' FOO 
' 'FOO 



828 Chapter 21 A Web Application Hacker's Methodology 



As always, be sure to URL-encode characters such as + and space that 
have special meaning within HTTP requests. 

7.2.5 If the original input is numeric, try using a mathematical expression that 
is equivalent to the original value. For example, if the original value was 
2, try submitting 1+1 or 3-1. If the application responds in the same way, 
it may be vulnerable, particularly if the value of the numeric expression 
has a systematic effect on the application's behavior. 

7.2.6 If the preceding test is successful, you can gain further assurance that 
a SQL injection vulnerability is involved by using SQL-specific math- 
ematical expressions to construct a particular value. If the application's 
logic can be systematically manipulated in this way, it is almost certainly 
vulnerable to SQL injection. For example, both of the following items 
are equivalent to the number 2: 

67-ASCII ( 1 A 1 ) 
51-ASCII (1) 

7.2.7 If either of the fuzz test cases using the wait for command resulted 
in an abnormal time delay before the application responded, this is a 
strong indicator that the database type is MS-SQL and the application 
is vulnerable to SQL injection. Repeat the test manually, specifying dif- 
ferent values in the wait for parameter, and determine whether the time 
taken to respond varies systematically with this value. Note that your 
attack payload may be inserted into more than one SQL query, so the 
time delay observed may be a fixed multiple of the value specified. 

7.2.8 If the application is vulnerable to SQL injection, consider what kinds 
of attacks are feasible and likely to help you achieve your objectives. 
Refer to Chapter 9 for the detailed steps needed to carry out any of the 
following attacks: 

■ Modify the conditions within a where clause to change the applica- 
tion's logic (for example, by injecting or 1=1 — to bypass a login). 

■ Use the union operator to inject an arbitrary select query and combine 
the results with those of the application's original query. 

■ Fingerprint the database type using database-specific SQL syntax. 

■ If the database type is MS-SQL and the application returns ODBC error 
messages in its responses, leverage these to enumerate the database 
structure and retrieve arbitrary data. 

■ If you cannot find a way to directly retrieve the results of an arbitrary 
injected query, use the following advanced techniques to extract data: 

■ Retrieve string data in numeric form, one byte at a time. 

■ Use an out-of-band channel. 



Chapter 21 A Web Application Hacker's Methodology 829 



■ If you can cause different application responses based on a single 
arbitrary condition, use Absinthe to extract arbitrary data one bit 
at a time. 

■ If you can trigger time delays based on a single arbitrary condition, 
exploit these to retrieve data one bit at a time. 

■ If the application is blocking certain characters or expressions that 
you require to perform a particular attack, try the various bypass 
techniques described in Chapter 9 to circumvent the input filter. 

■ If possible, escalate the attack against the database and the underly- 
ing server by leveraging any vulnerabilities or powerful functions 
within the database. 

7.3 Test for XSS and Other Response Injection 

7.3. 1 Identify Reflected Request Parameters 

7.3.1 .1 Sort the results of your fuzz testing by clicking the Pay load Grep column, 
and identify any matches corresponding to the XSS payloads listed in 
step 7.1.3. These are cases where the XSS test strings were returned 
unmodified within the application's responses. 

7.3.1.2 For each of these cases, review the application's response to find the loca- 
tion of the supplied input. If this appears within the response body, test 
for XSS vulnerabilities. If the input appears within any HTTP header, test 
for header injection vulnerabilities. If it is used in the Location header 
of a 302 response, or if it is used to specify a redirect in some other way, 
test for redirection vulnerabilities. Note that the same input might be 
copied into multiple locations within the response, and that more than 
one type of reflected vulnerability might be present. 

7.3.2 Test for Reflected XSS 

7.3.2.1 For each place within the response body where the value of the request 
parameter appears, review the surrounding HTML to identify possible 
ways of crafting your input to cause execution of arbitrary JavaScript. 
For example, you can inject <script> tags, inject into an existing script, 
or place a crafted value into a tag attribute. 

7.3.2.2 Use the different methods of beating signature-based filters described in 
Chapter 12 as a reference for the different ways in which crafted input 
can be used to cause execution of JavaScript. 

7.3.2.3 Try submitting various possible exploits to the application, and monitor 
its responses to determine whether any filtering or sanitization of input 



830 Chapter 21 A Web Application Hacker's Methodology 



is being performed. If your attack string is returned unmodified, use a 
browser to verify conclusively that you have succeeded in executing 
arbitrary JavaScript (for example, by generating an alert dialog). 

7.3.2.4 If you find that the application is blocking input containing certain 
characters or expressions you need to use, or is HTML-encoding certain 
characters, try the various filter bypasses described in Chapter 12. 

7.3.2.5 If you find an XSS vulnerability in a post request, this can still be 
exploited via a malicious website that contains a form with the required 
parameters and a script to automatically submit the form. Nevertheless, 
a wider range of attack delivery mechanisms is available if the exploit 
can be delivered via a get request. Try submitting the same parameters 
in a get request, and see if the attack still succeeds. You can use the 
Change Request Method action in Burp Proxy to convert the request 
for you. 

7.3.3 Test for HTTP Header Injection 

7.3.3.1 For each place within the response headers where the value of the request 
parameter appears, verify whether the application accepts data contain- 
ing URL-encoded carriage-return (%od) and line-feed (%0a) characters 
and whether these are returned unsanitized in its response. (Note that 
you are looking for the actual newline characters themselves to appear 
in the server's response, not their URL-encoded equivalents.) 

7.3.3.2 If a new line appears in the server's response headers when you sup- 
ply crafted input, the application is vulnerable to HTTP header injec- 
tion. This can be leveraged to perform various attacks, as described in 
Chapter 13. 

7.3.3.3 If you find that only one of the two newline characters gets returned in 
the server's responses, it may still be possible to craft a working exploit, 
depending on the context and the target user's browser. 

7.3.3.4 If you find that the application blocks input containing newline charac- 
ters, or sanitizes those characters in its response, try the following items 
of input to test the filter's effectiveness: 

f oo%00%0d%0abar 
f oo%250d%250abar 
foo%%0d0d%%0a0abar 

7.3.4 Test for Open Redirection 

7.3.4.1 If the reflected input is used to specify the target of a redirect of some 
kind, test whether it is possible to supply crafted input that results in 



Chapter 21 A Web Application Hacker's Methodology 851 



an arbitrary redirect to an external website. If so, this behavior can be 
exploited to lend credibility to a phishing-style attack. 

7.3.4.2 If the application ordinarily transmits an absolute URL as the parameter's 
value, modify the domain name within the URL, and test whether the 
application redirects you to the different domain. 

7.3.4.3 If the parameter normally contains a relative URL, modify this into an 
absolute URL for a different domain, and test whether the application 
redirects you to this domain. 

7.3.4.4 If the application carries out some validation on the parameter before 
performing the redirect, in an effort to prevent external redirection, 
this is often vulnerable to bypasses. Try the various attacks described 
in Chapter 13 to test the robustness of the filters. 

7.5.5 Test for Stored Attacks 

7.3.5.1 If the application stores items of user-supplied input and later displays these 
on-screen, after you have fuzzed the entire application you may observe 
some of your attack strings being returned in responses to requests that did 
not themselves contain those strings. Note any instances where this occurs, 
and identify the original entry point for the data that is being stored. 

7.3.5.2 In some cases, user-supplied data is stored successfully only if you com- 
plete a multistage process, which does not occur in basic fuzz testing. If 
your application mapping exercises identified any functionality of this 
kind, manually walk through the relevant process and test the stored 
data for XSS vulnerabilities. 

7.3.5.3 If you have sufficient access to test it, review closely any administrative 
functionality in which data originating from low-privileged users is 
ultimately rendered on-screen in the session of more privileged users. 
Any stored XSS vulnerabilities in functionality of this kind typically lead 
directly to privilege escalation. 

7.3.5.4 Test every instance where user-supplied data is stored and displayed 
to users. Probe these for XSS and the other response injection attacks 
described previously. 

7.3.5.5 If you find a vulnerability in which input supplied by one user is displayed 
to other users, determine the most effective attack payload with which 
you can achieve your objectives, such as session hijacking or request 
forgery. If the stored data is displayed only to the same user from whom 
it originated, try to find ways of chaining any other vulnerabilities you 
have discovered (such as broken access controls) to inject an attack into 
other users' sessions. 



832 Chapter 21 A Web Application Hacker's Methodology 



7.3.5.6 If the application allows upload and download of files, always probe this 
functionality for stored XSS attacks. If the application allows HTML, JAR, 
or text files, and does not validate or sanitize their contents, it is almost 
certainly vulnerable. If it allows JPEG files and does not validate that 
they contain valid images, it is probably vulnerable to attacks against 
Internet Explorer users. Test the application's handling of each file type 
it supports, and confirm how browsers handle responses containing 
HTML instead of the normal content type. 

7.3.5.7 In every location where data submitted by one user is displayed to other 
users but where the application's filters prevent you from performing 
a stored XSS attack, review whether the application's behavior leaves 
it vulnerable to on-site request forgery. 

7.4 Test for OS Command Injection 

7.4. 1 If any of the command injection attack strings listed in step 7.1.3 resulted 
in an abnormal time delay before the application responded, this is a 
strong indicator that the application is vulnerable to OS command injec- 
tion. Repeat the test, manually specifying different values in the -i or 
-n parameter, and determine whether the time taken to respond varies 
systematically with this value. 

7.4.2 Using whichever of the injection strings was found to be successful, try 
injecting a more interesting command (such as is or dir), and determine 
whether you can retrieve the results of the command to your browser. 

7.4.3 If you are unable to retrieve results directly, other options are open to 
you: 

■ You can attempt to open an out-of-band channel back to your com- 
puter. Try using TFTP to copy tools up to the server, using telnet or 
netcat to create a reverse shell back to your computer, and using the 
mail command to send command output via SMTP. 

■ You can redirect the results of your commands to a file within the 
web root, which you can then retrieve directly using your browser. 
For example: 

dir > c:\inetpub\wwwroot\foo.txt 

7.4.4 If you find a way to inject commands and retrieve the results, you should 
determine your privilege level (by using whoami or a similar command, 
or attempting to write a harmless file to a protected directory). You 
may then seek to escalate privileges, gain backdoor access to sensitive 
application data, or attack other hosts that can be reached from the 
compromised server. 



Chapter 21 A Web Application Hacker's Methodology 855 



7.4.5 If you believe that your input is being passed to an OS command of 
some kind, but the attack strings listed are unsuccessful, see if you can 
use the < or > character to direct the contents of a file to the command's 
input or to direct the command's output to a file. This may enable you 
to read or write arbitrary file contents. If you know or can guess the 
actual command being executed, try injecting command-line parameters 
associated with that command to modify its behavior in useful ways 
(for example, by specifying an output file within the web root). 

7.4.6 If you find that the application is escaping certain key characters you need 
to perform a command injection attack, try placing the escape character 
before each such character. If the application does not escape the escape 
character itself, this usually leads to a bypass of this defensive measure. 
If you find that whitespace characters are blocked or sanitized, you may 
be able to use $ifs in place of spaces on UNIX-based platforms. 

7.5 Test for Path Traversal 

7.5.1 For each fuzz test you have performed, review the results generated 
by the path traversal attack strings listed in step 7.1.3. You can click the 
top of the payload column in Burp Intruder to sort the results table by 
payload and group the results for these strings. For any cases where 
an unusual error message or a response with an abnormal length was 
received, review the response manually to determine whether it contains 
the contents of the specified file or other evidence that an anomalous 
file operation occurred. 

7.5.2 In your mapping of the application's attack surface, you should have 
noted any functionality that specifically supports the reading and writ- 
ing of files on the basis of user-supplied input. In addition to the general 
fuzzing of all parameters, you should manually test this functionality 
very carefully to identify any path traversal vulnerabilities that exist. 

7.5.3 Where a parameter appears to contain a filename, a portion of a file- 
name, or a directory, modify the parameter's existing value to insert an 
arbitrary subdirectory and a single traversal sequence. For example, if 
the application submits this parameter: 

f ile=f oo/ f ilel . txt 

try submitting this value: 

f ile=f oo/bar / . . /f ilel . txt 

If the application's behavior is identical in the two cases, it may be 
vulnerable, and you should proceed to the next step. If the behavior 
is different, the application may be blocking, stripping, or sanitizing 



854 Chapter 21 A Web Application Hacker's Methodology 



traversal sequences, resulting in an invalid file path. Try using the 
encoding and other attacks described in Chapter 10 in an attempt to 
bypass the filters. 

If the preceding test of using traversal sequences within the base 
directory is successful, try using additional sequences to step above 
the base directory and access known files on the server's operating 
system. If these attempts fail, the application may be imposing vari- 
ous filters or checks before file access is granted. You should probe 
further to understand the controls that are implemented and whether 
any bypasses exist. 

The application may be checking the file extension being requested 
and allowing access to only certain kinds of files. Try using a null byte 
or newline attack together with a known accepted file extension in an 
attempt to bypass the filter. For example: 

../../../../.. /boot . ini%00 . jpg 
../../../../.. /etc/passwd%0a . jpg 

7.5.6 The application may be checking that the user-supplied file path starts with 
a particular directory or stem. Try appending traversal sequences after 
a known accepted stem in an attempt to bypass the filter. For example: 

/images/ ../../../../../../.. /etc/passwd 

7.5.7 If these attacks are unsuccessful, try combining multiple bypasses, 
working initially entirely within the base directory in an attempt to 
understand the filters in place and the ways in which the application 
handles unexpected input. 

7.5.8 If you succeed in gaining read access to arbitrary files on the server, 
attempt to retrieve any of the following files, which may enable you to 
escalate your attack: 

■ Password files for the operating system and application 

■ Server and application configuration files, to discover other vulner- 
abilities or fine-tune a different attack 

■ Include files that may contain database credentials 

■ Data sources used by the application, such as MySQL database files 
or XML files 

■ The source code to server-executable pages, to perform a code review 
in search of bugs 

■ Application log files that may contain information such as usernames 
and session tokens 



7.5.4 



7.5.5 



Chapter 21 A Web Application Hacker's Methodology 855 



7.5.9 If you succeed in gaining write access to arbitrary files on the server, 
examine whether any of the following attacks are feasible in order to 
escalate your attack: 

■ Creating scripts in users' startup folders 

■ Modifying files such as in . f tpd to execute arbitrary commands when 
a user next connects 

■ Writing scripts to a web directory with execute permissions and call- 
ing them from your browser 



7.6.1 For each fuzz test you have performed, review the results for the string 
mill on its own (that is, not preceded by the rest of the test string). 
You can quickly identify these in Burp Intruder by Shift-clicking the 
heading for the mill Grep string to group all the results containing 
this string. Look for any that do not have a check in the Payload Grep 
column. Any cases identified are likely to be vulnerable to injection of 
scripting commands. 

7.6.2 Review all the test cases that used script injection strings, and identify 
any containing scripting error messages that may indicate that your input 
is being executed but caused an error. These may need to be fine-tuned 
to perform successful script injection. 

7.6.3 If the application appears to be vulnerable, verify this by injecting fur- 
ther commands specific to the scripting platform in use. For example, 
you can use attack payloads similar to those used when fuzzing for OS 
command injection: 

system ( 'ping%20127 .0.0.1') 



7.7.1 If you received any incoming HTTP connections from the target appli- 
cation's infrastructure during your fuzzing, the application is almost 
certainly vulnerable to remote file inclusion. Repeat the relevant tests 
in a single- threaded and time- throttled way to determine exactly which 
parameters are causing the application to issue the HTTP requests. 

7.7.2 Review the results of the file inclusion test cases, and identify any that 
caused an anomalous delay in the application's response. In these cases, 
it may be that the application itself is vulnerable but that the resulting 
HTTP requests are timing out due to network-level filters. 



7.6 



Test for Script Injection 



7.7 



Test for File Inclusion 



856 Chapter 21 A Web Application Hacker's Methodology 



7.7.3 If you find a remote file inclusion vulnerability, deploy a web server 
containing a malicious script specific to the language you are targeting, 
and use commands such as those used to test for script injection to verify 
that your script is being executed. 

8 Test for Function-Specific Input Vulnerabilities 



In addition to the input-based attacks targeted in the preceding step, a range 
of vulnerabilities normally manifest themselves only in particular kinds of 
functionality. Before proceeding to the individual steps described in this sec- 
tion, you should review your assessment of the application's attack surface to 
identify specific application functions where these defects are liable to arise, 
and focus your testing on those. 



Application mapping results 


V 




V 




V 




V 




V 




V 




V 


8.1. SMTP 
injection 




8.2. Native 
code flaws 




8.3. SOAP 
injection 




8.4. LDAP 
injection 




8.5. XPath 
injection 




8.6. Back-end 
request 
injection 




8.7. XXE 
injection 



Figure 21-9: Testing for functionality-specific input vulnerabilities 



8.1 Test for SMTP Injection 

8.1.1 For each request employed in e-mail-related functionality, submit each 
of the following test strings as each parameter in turn, inserting your 
own e-mail address at the relevant position. You can use Burp Intruder 
to automate this, as described in step 7.1 for general fuzzing. These test 
strings already have special characters URL-encoded, so do not apply 
any additional encoding to them. 

<youremail>%OaCc : <youremail> 
<youremail>%0d%0aCc : <youremail> 
<youremail>%OaBcc : <youremail> 
<youremail>%0d%0aBcc : <youremail> 

%0aDATA%0af oo%0a%2e%0aMAIL+FROM: +<youremail>%0aRCPT+TO : +<youremail> 



Chapter 21 A Web Application Hacker's Methodology 857 



%0aDATA%0aFrom : +<youremail>%OaTo : +<youremail>%OaSubj ect : +test%0af oo 
%0a%2e%0a 

%0d%0aDATA%0d%0af oo%0d%0a%2e%0d%0aMAIL+FROM: +<youremail>%0d%0aRCPT 
+T0 : + 

<youremail>%0d%0aDATA%0d%0aFrom : +<youremail>%0d%0aTo : +<youremail> 
%0d%0aSubject : +test%0d%0af oo%0d%0a%2e%0d%0a 

8.1.2 Review the results to identify any error messages the application returns. 
If these appear to relate to any problem in the e-mail function, investigate 
whether you need to fine-tune your input to exploit a vulnerability. 

8.1.3 Monitor the e-mail address you specified to see if any e-mail messages 
are received. 

8.1.4 Review closely the HTML form that generates the relevant request. It 
may contain clues regarding the server-side software being used. It 
may also contain a hidden or disabled field that is used to specify the 
To address of the e-mail, which you can modify directly. 

8.2 Test for Native Software Vulnerabilities 

8.2. 7 Test for Buffer Overflows 

8.2.1.1 For each item of data being targeted, submit a range of long strings with 
lengths somewhat longer than common buffer sizes. Target one item of 
data at a time to maximize the coverage of code paths in the application. 
You can use the character blocks payload source in Burp Intruder to 
automatically generate payloads of various sizes. The following buffer 
sizes are suitable to test: 

1100 
4200 
33000 

8.2.1.2 Monitor the application's responses to identify any anomalies. An uncon- 
trolled overflow is almost certain to cause an exception in the applica- 
tion, although diagnosing the nature of the problem remotely may be 
difficult. Look for any of the following anomalies: 

■ An HTTP 500 status code or error message, where other malformed 
(but not overlong) input does not have the same effect 

■ An informative message indicating that a failure occurred in some 
external, native code component 

■ A partial or malformed response being received from the server 

■ The TCP connection to the server closing abruptly without returning 
a response 



858 Chapter 21 A Web Application Hacker's Methodology 



■ The entire web application no longer responding 

■ Unexpected data being returned by the application, possibly indicat- 
ing that a string in memory has lost its null terminator 



8.2.2 Test for Integer Vulnerabilities 

8.2.2.1 When dealing with native code components, identify any integer-based 
data, particularly length indicators, which may be used to trigger integer 
vulnerabilities. 

8.2.2.2 Within each targeted item, send suitable payloads designed to trigger 
any vulnerabilities. For each item of data being targeted, send a series 
of different values in turn, representing boundary cases for the signed 
and unsigned versions of different sizes of integer. For example: 

■ 0x7f and 0x80 (127 and 128) 

■ Oxff and 0x100 (255 and 256) 

■ 0x7ffff and 0x8000 (32767 and 32768) 

■ Oxffff and 0x10000 (65535 and 65536) 

■ 0x7fffffff and 0x80000000 (2147483647 and 2147483648) 

■ Oxffffffff and 0x0 (4294967295 and 0) 

8.2.2.3 When the data being modified is represented in hexadecimal form, send 
both little-endian and big-endian versions of each test case, such as f f 7 f 
and 7f f f. If hexadecimal numbers are submitted in ASCII form, use 
the same case as the application itself uses for alphabetic characters to 
ensure that these are decoded correctly. 

8.2.2.4 Monitor the application's responses for anomalous events, as described 
in step 8.2.1.2. 

8.2.3 Test for Format String Vulnerabilities 

8.2.3.1 Targeting each parameter in turn, submit strings containing long sequences 
of different format specifiers. For example: 

%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n 
%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s 

%l!n!%2!n!%3!n!%4!n!%5!n!%6!n!%7!n!%8!n!%9!n!%10!n! etc . . . 
%l!s!%2!s!%3!s!%4!s!%5!s!%6!s!%7!s!%8!s!%9!s!%10!s! etc . . . 

Remember to URL-encode the % character as %2 5. 

8.2.3.2 Monitor the application's responses for anomalous events, as described 
in step 8.2.1.2. 



Chapter 21 A Web Application Hacker's Methodology 859 



8.3 



Test for SOAP Injection 



8.3.1 Target each parameter in turn that you suspect is being processed via 
a SOAP message. Submit a rogue XML closing tag, such as </foo>. If 
no error occurs, your input is probably not being inserted into a SOAP 
message or is being sanitized in some way. 

8.3.2 If an error was received, submit instead a valid opening and closing 
tag pair, such as <f oo></f oo>. If this causes the error to disappear, the 
application may be vulnerable. 

8.3.3 If the item you submit is copied back into the application's responses, 
submit the following two values in turn. If you find that either item is 
returned as the other, or as simply test, you can be confident that your 
input is being inserted into an XML-based message. 

test<f oo/> 
test<f oo></ f oo> 

8.3.4 If the HTTP request contains several parameters that may be being 
placed into a SOAP message, try inserting the opening comment char- 
acter < ! - - into one parameter and the closing comment character ! — > 
into another parameter. Then switch these (because you have no way 
of knowing in which order the parameters appear). This can have the 
effect of commenting out a portion of the server's SOAP message, which 
may change the application's logic or result in a different error condition 
that may divulge information. 



8.4.1 In any functionality where user-supplied data is used to retrieve infor- 
mation from a directory service, target each parameter in turn to test 
for potential injection into an LDAP query. 

8.4.2 Submit the * character. If a large number of results are returned, this is 
a good indicator that you are dealing with an LDAP query. 

8.4.3 Try entering a number of closing parentheses: 

)))))))))) 

This input invalidates the query syntax, so if an error or other anomalous 
behavior results, the application may be vulnerable (although many 
other application functions and injection situations may behave in the 
same way). 

8.4.4 Try entering various expressions designed to interfere with different 
types of queries, and see if these allow you to influence the results being 



8.4 



Test for LDAP Injection 



840 Chapter 21 A Web Application Hacker's Methodology 



returned. The cn attribute is supported by all LDAP implementations 
and is useful if you do not know any details about the directory you are 
querying: 

) (cn=* 

*) ) ( I (cn=* 

*) ) %00 

8.4.5 Try adding extra attributes to the end of your input, using commas to 
separate each item. Test each attribute in turn. An error indicates that 
the attribute is not valid in the present context. The following attributes 
are commonly used in directories queried by LDAP: 

cn 
c 

mail 

givenname 
o 

ou 
dc 

1 

uid 

obj ectclass 

postaladdress 

dn 

sn 

8.5 Test for XPath Injection 

8.5.1 Try submitting the following values, and determine whether they result 
in different application behavior without causing an error: 

1 or count (parent ::* [position () =1 ]) =0 or ' a'='b 
1 or count (parent ::* [position () =1 ]) >0 or ' a'='b 

8.5.2 If the parameter is numeric, also try the following test strings: 

1 or count (parent ::* [position () =1 ]) =0 
1 or count (parent ::* [position () =1 ]) >0 

8.5.3 If any of the preceding strings causes differential behavior within the 
application without causing an error, it is likely that you can extract 
arbitrary data by crafting test conditions to extract 1 byte of information 
at a time. Use a series of conditions with the following form to determine 
the name of the current node's parent: 



substring (name (parent : : * [position ()=!] ) ,1,1)=' a 



Chapter 21 A Web Application Hacker's Methodology 841 



8.5.4 Having extracted the name of the parent node, use a series of conditions 
with the following form to extract all the data within the XML tree: 

substring ( / /parentnodename [position ( ) =1 ] /child : : node ( ) [position () =1 ] 
/text ( ) , 1, 1) = 1 a 1 

8.6 Test for Back-End Request Injection 

8.6.1 Locate any instance where an internal server name or IP address is 
specified in a parameter. Submit an arbitrary server and port, and 
monitor the application for a timeout. Also submit localhost, and 
finally your own IP address, monitoring for incoming connections on 
the port specified. 

8.6.2 Target a request parameter that returns a specific page for a specific 
value, and try to append a new injected parameter using various syntax, 
including the following: 

%2 6foo%3dbar (URL-encoded &foo=bar) 

%3bf oo%3dbar (URL-encoded ; f oo=bar) 

%2526foo%253dbar (Double URL-encoded &foo=bar) 

If the application behaves as if the original parameter were unmodified, 
there is a chance of HTTP parameter injection vulnerabilities. Attempt 
to attack the back-end request by injecting known parameter name/ 
value pairs that may alter the back-end logic, as described in Chapter 10. 

8.7 Test for XXE Injection 

8.7.1 If users are submitting XML to the server, an external entity injection 
attack may be possible. If a field is known that is returned to the user, 
attempt to specify an external entity, as in the following example: 

POST /search/128/AjaxSearch.ashx HTTP/1.1 
Host: mdsec.net 

Content-Type: text/xml; charset=UTF-8 
Content-Length: 115 

<!DOCTYPE foo [ <! ENTITY xxe SYSTEM " file :// /windows/win . ini " > ]> 
<Search><SearchTerm>&xxe ; < / SearchTermx / Search> 

If no known field can be found, specify an external entity of 
"http: / /192. 168. 1.1:25" and monitor the page response time. If the 
page takes significantly longer to return or times out, it may be vulnerable. 



842 Chapter 21 A Web Application Hacker's Methodology 



9 Test for Logic Flaws 



9.1 . Identify key attack surface 



V 


V 


\7 


V 


9.2. 
Multistage 
processes 




9.3. 
Incomplete 
input 




9.4. 
Trust 
boundaries 




9.5. 

Transaction 
logic 



Figure 21-10: Testing for logic flaws 



9.1 Identify the Key Attack Surface 

9.1.1 Logic flaws can take a huge variety of forms and exist within any aspect 
of the application's functionality. To ensure that probing for logic flaws 
is feasible, you should first narrow down the attack surface to a reason- 
able area for manual testing. 

9.1.2 Review the results of your application mapping exercises, and identify 
any instances of the following features: 

■ Multistage processes 

■ Critical security functions, such as login 

■ Transitions across trust boundaries (for example, moving from being 
anonymous to being self -registered to being logged in) 

■ Context-based functionality presented to a user 

■ Checks and adjustments made to transaction prices or quantities 

9.2 Test Multistage Processes 

9.2.1 When a multistage process involves a defined sequence of requests, 
attempt to submit these requests out of the expected sequence. Try 
skipping certain stages, accessing a single stage more than once, and 
accessing earlier stages after later ones. 

9.2.2 The sequence of stages may be accessed via a series of get or post 
requests for distinct URLs, or they may involve submitting different 
sets of parameters to the same URL. You may specify the stage being 



Chapter 21 A Web Application Hacker's Methodology 845 



requested by submitting a function name or index within a request 
parameter. Be sure to understand fully the mechanisms that the applica- 
tion is employing to deliver access to distinct stages. 

9.2.3 In addition to interfering with the sequence of steps, try taking param- 
eters that are submitted at one stage of the process and submitting them 
at a different stage. If the relevant items of data are updated within the 
application's state, you should investigate whether you can leverage 
this behavior to interfere with the application's logic. 

9.2.4 If a multistage process involves different users performing operations 
on the same set of data, try taking each parameter submitted by one user 
and submitting it as another. If they are accepted and processed as that 
user, explore the implications of this behavior, as described previously. 

9.2.5 From the context of the functionality that is implemented, try to under- 
stand what assumptions the developers may have made and where the 
key attack surface lies. Try to identify ways of violating those assump- 
tions to cause undesirable behavior within the application. 

9.2.6 When multistage functions are accessed out of sequence, it is common 
to encounter a variety of anomalous conditions within the application, 
such as variables with null or uninitialized values, partially defined or 
inconsistent state, and other unpredictable behavior. Look for inter- 
esting error messages and debug output, which you can use to better 
understand the application's internal workings and thereby fine-tune 
the current or a different attack. 

9.3 Test Handling of Incomplete Input 

9.3.1 For critical security functions within the application, which involve 
processing several items of user input and making a decision based on 
these, test the application's resilience to requests containing incomplete 
input. 

9.3.2 For each parameter in turn, remove both the name and value of the 
parameter from the request. Monitor the application's responses for 
any divergence in its behavior and any error messages that shed light 
on the logic being performed. 

9.3.3 If the request you are manipulating is part of a multistage process, follow 
the process through to completion, because the application may store 
data submitted in earlier stages within the session and then process this 
at a later stage. 



844 Chapter 21 A Web Application Hacker's Methodology 



9.4 Test Trust Boundaries 

9.4.1 Probe how the application handles transitions between different types 
of trust of the user. Look for functionality where a user with a given 
trust status can accumulate an amount of state relating to his identity. 
For example, an anonymous user could provide personal information 
during self -registration, or proceed through part of an account recovery 
process designed to establish his identity. 

9.4.2 Try to find ways to make improper transitions across trust boundaries 
by accumulating relevant state in one area and then switching to a 
different area in a way that would not normally occur. For example, 
having completed part of an account recovery process, attempt to 
switch to an authenticated user-specific page. Test whether the appli- 
cation assigns you an inappropriate level of trust when you transition 
in this way. 

9.4.3 Try to determine whether you can harness any higher-privileged func- 
tion directly or indirectly to access or infer information. 

9.5 Test Transaction Logic 

9.5.1 In cases where the application imposes transaction limits, test the 
effects of submitting negative values. If these are accepted, it may be 
possible to beat the limits by making large transactions in the opposite 
direction. 

9.5.2 Examine whether you can use a series of successive transactions to bring 
about a state that you can exploit for a useful purpose. For example, you 
may be able to perform several low -value transfers between accounts 
to accrue a large balance that the application's logic was intended to 
prevent. 

9.5.3 If the application adjusts prices or other sensitive values based on criteria 
that are determined by user-controllable data or actions, first understand 
the algorithms used by the application, and the point within its logic 
where adjustments are made. Identify whether these adjustments are 
made on a one-time basis, or whether they are revised in response to 
further actions performed by the user. 

9.5.4 Try to find ways to manipulate the application's behavior to cause it to 
get into a state where the adjustments it has applied do not correspond 
to the original criteria intended by its designers. 



Chapter 21 A Web Application Hacker's Methodology 845 



10 Test for Shared Hosting Vulnerabilities 



10.1. Test segregation in shared infrastructures 



10.2. Test segregation between ASP-hosted applications 



Figure 21-11: Testing for shared hosting vulnerabilities 

10.1 Test Segregation in Shared Infrastructures 

10.1.1 If the application is hosted in a shared infrastructure, examine the access 
mechanisms provided for customers of the shared environment to update 
and manage their content and functionality. Consider the following 
questions: 

■ Does the remote access facility use a secure protocol and suitably 
hardened infrastructure? 

■ Can customers access files, data, and other resources that they do not 
legitimately need to access? 

■ Can customers gain an interactive shell within the hosting environ- 
ment and execute arbitrary commands? 

10.1.2 If a proprietary application is used to allow customers to configure and 
customize a shared environment, consider targeting this application as 
a way to compromise the environment itself and individual applications 
running within it. 

10.1.3 If you can achieve command execution, SQL injection, or arbitrary file 
access within one application, investigate carefully whether this provides 
any way to escalate your attack to target other applications. 

10.2 Test Segregation Between ASP-Hosted Applications 

10.2.1 If the application belongs to an ASP-hosted service composed of a 
mix of shared and customized components, identify any shared com- 
ponents such as logging mechanisms, administrative functions, and 
database code components. Attempt to leverage these to compromise 
the shared portion of the application and thereby attack other individual 
applications. 



846 Chapter 21 A Web Application Hacker's Methodology 



10.2.2 If a common database is used within any kind of shared environment, 
perform a comprehensive audit of the database configuration, patch level, 
table structure, and permissions using a database scanning tool such as 
NGSSquirrel. Any defects within the database security model may pro- 
vide a way to escalate an attack from within one application to another. 

1 1 Test for Application Server Vulnerabilities 



11.1. Test for default credentials 



1 1 .2. Test for default content 



1 1 .3. Test for dangerous HTTP methods 



1 1 .4. Test for proxy functionality 



1 1 .5. Test for virtual hosting misconfiguration 



1 1 .6. Test for web server software bugs 



1 1 .7. Test for web application firewalling 



Figure 21-12: Testing for web server vulnerabilities 

1 1 .1 Test for Default Credentials 

11.1.1 Review the results of your application mapping exercises to identify the 
web server and other technologies in use that may contain accessible 
administrative interfaces. 

11.1.2 Perform a port scan of the web server to identify any administrative 
interfaces running on a different port than the main target application. 

11.1.3 For any identified interfaces, consult the manufacturer's documentation 
and common default password listings to obtain default credentials. 

11.1.4 If the default credentials do not work, use the steps listed in section 4 
to attempt to guess valid credentials. 

11.1.5 If you gain access to an administrative interface, review the available 
functionality and determine whether it can be used to further compro- 
mise the host and attack the main application. 



Chapter 21 A Web Application Hacker's Methodology 847 



1 1 .2 Test for Default Content 

11.2.1 Review the results of your Nikto scan (step 1.4.1) to identify any default 
content that may be present on the server but that is not an integral part 
of the application. 

11.2.2 Use search engines and other resources such as www . exploit-db . com and 
www. osvdb. org to identify default content and functionality included 
within the technologies you know to be in use. If feasible, carry out a 
local installation of these, and review them for any default functionality 
that you may be able to leverage in your attack. 

11.2.3 Examine the default content for any functionality or vulnerabilities that 
you may be able to leverage to attack the server or the application. 

11.3 Test for Dangerous HTTP Methods 

11.3.1 Use the options method to list the HTTP methods that the server states 
are available. Note that different methods may be enabled in different 
directories. You can perform a vulnerability scan in Paros to perform 
this check. 

11.3.2 Try each reported method manually to confirm whether it can in fact be 
used. 

11.3.3 If you find that some WebDAV methods are enabled, use a WebDAV- 
enabled client for further investigation, such as Microsoft FrontPage or 
the Open as Web Folder option in Internet Explorer. 

11.4 Test for Proxy Functionality 

11.4.1 Using both get and connect requests, try to use the web server as a 
proxy to connect to other servers on the Internet and retrieve content 
from them. 

1 1 .4.2 Using both get and connect requests, attempt to connect to different IP 
addresses and ports within the hosting infrastructure. 

11.4.3 Using both get and connect requests, attempt to connect to common 
port numbers on the web server itself by specifying 127.0.0.1 as the target 
host in the request. 

11.5 Test for Virtual Hosting Misconfiguration 

11.5.1 Submit get requests to the root directory using the following: 

■ The correct Host header 

■ A bogus Host header 



848 Chapter 21 A Web Application Hacker's Methodology 



■ The server's IP address in the Host header 

■ No Host header (use HTTP/ 1.0 only) 

11.5.2 Compare the responses to these requests. A common result is that direc- 
tory listings are obtained when the server's IP address is used in the Host 
header. You may also find that different default content is accessible. 

11.5.3 If you observe different behavior, repeat the application mapping exer- 
cises described in section 1 using the hostname that generated different 
results. Be sure to perform a Nikto scan using the -vhost option to iden- 
tify any default content that may have been overlooked during initial 
application mapping. 



11.6.1 Run Nessus and any other similar scanners you have available to identify 
any known vulnerabilities in the web server software you are attacking. 

11.6.2 Review resources such as Security Focus, Bugtraq, and Full Disclosure 
to find details of any recently discovered vulnerabilities that may not 
have been fixed on your target. 

1 1 .6.3 If the application was developed by a third party, investigate whether it 
ships with its own web server (often an open source server). If it does, 
investigate this for any vulnerabilities. Be aware that in this case, the 
server's standard banner may have been modified. 

11.6.4 If possible, consider performing a local installation of the software you 
are attacking, and carry out your own testing to find new vulnerabilities 
that have not been discovered or widely circulated. 



11.7.1 Submit an arbitrary parameter name to the application with a clear attack 
payload in the value, ideally somewhere the application includes the 
name and /or value in the response. If the application blocks the attack, 
this is likely to be due to an external defense. 

1 1.7.2 If a variable can be submitted that is returned in a server response, submit 
a range of fuzz strings and encoded variants to identify the behavior of 
the application defenses to user input. 

11.7.3 Confirm this behavior by performing the same attacks on variables 
within the application. 

1 1 .7.4 For all fuzzing strings and requests, use payload strings that are unlikely 
to exist in a standard signature database. Although giving examples of 



11.6 



Test for Web Server Software Bugs 



11.7 



Test for Web Application Firewalling 



Chapter 21 A Web Application Hacker's Methodology 849 



these is by definition impossible, avoid using /etc/passwdor /windows/ 
system32/conf ig/sam as payloads for file retrieval. Also avoid using 
terms such as <script> in an XSS attack and using alert ( ) or xss as 
XSS payloads. 

11.7.5 If a particular request is blocked, try submitting the same parameter in a 
different location or context. For instance, submit the same parameter in 
the URL in a get request, within the body of a post request, and within 
the URL in a post request. 

11.7.6 On ASP.NET, also try submitting the parameter as a cookie. The API 
Request . Params [ " f oo " ] will retrieve the value of a cookie named f oo 
if the parameter f oo is not found in the query string or message body. 

11.7.7 Review all the other methods of introducing user input provided in 
Chapter 4, picking any that are not protected. 

11.7.8 Determine locations where user input is (or can be) submitted in a non- 
standard format such as serialization or encoding. If none is available, 
build the attack string by concatenation and/ or by spanning it across 
multiple variables. (Note that if the target is ASP.NET, you may be able 
to use HPP to concatenate the attack using multiple specifications of the 
same variable.) 

12 Miscellaneous Checks 



12.1 . Test for DOM-based attacks 



12.2. Test tor local privacy vulnerabilities 



12.3. Test for weak SSL ciphers 



12.4. Check same-orgin policy configuration 



Figure 21-13: Miscellaneous checks 

12.1 Check for DOM-Based Attacks 

12.1.1 Perform a brief code review of every piece of JavaScript received from 
the application. Identify any XSS or redirection vulnerabilities that can 
be triggered by using a crafted URL to introduce malicious data into 
the DOM of the relevant page. Include all standalone JavaScript files 



850 Chapter 21 A Web Application Hacker's Methodology 



and scripts contained within HTML pages (both static and dynamically 
generated). 

12.1.2 Identify all uses of the following APIs, which may be used to access 
DOM data that can be controlled via a crafted URL: 

document . location 
document . URL 
document . URLUnencoded 
document . ref errer 
window . location 

12.1.3 Trace the relevant data through the code to identify what actions are 
performed with it. If the data (or a manipulated form of it) is passed to 
one of the following APIs, the application may be vulnerable to XSS: 

document .write ( ) 
document .writeln ( ) 
document . body . innerHtml 
eval ( ) 

window. execScript ( ) 
window. setlnterval ( ) 
window . setTimeout ( ) 

12.1.4 If the data is passed to one of the following APIs, the application may 
be vulnerable to a redirection attack: 

document . location 
document . URL 
document . open ( ) 
window . location . href 
window . navigate ( ) 
window . open ( ) 

12.2 Check for Local Privacy Vulnerabilities 

12.2.1 Review the logs created by your intercepting proxy to identify all the 
Set-Cookie directives received from the application during your test- 
ing. If any of these contains an expires attribute with a date that is in 
the future, the cookie will be stored by users' browsers until that date. 
Review the contents of any persistent cookies for sensitive data. 

12.2.2 If a persistent cookie is set that contains any sensitive data, a local attacker 
may be able to capture this data. Even if the data is encrypted, an attacker 
who captures it will be able to resubmit the cookie to the application 
and gain access to any data or functionality that this allows. 

12.2.3 If any application pages containing sensitive data are accessed over 
HTTP, look for any cache directives within the server's responses. If any 
of the following directives do not exist (either within the HTTP headers 



Chapter 21 A Web Application Hacker's Methodology 851 



or within HTML metatags), the page concerned may be cached by one 
or more browsers: 

Expires : 

Cache-control: no-cache 
Pragma: no-cache 

12.2.4 Identify any instances within the application in which sensitive data is 
transmitted via a URL parameter. If any cases exist, examine the browser 
history to verify that this data has been stored there. 

12.2.5 For all forms that are used to capture sensitive data from the user (such 
as credit card details), review the form's HTML source. If the attribute 
autocomplete=of f is not set, within either the form tag or the tag for the 
individual input field, data entered is stored within browsers that sup- 
port autocomplete, provided that the user has not disabled this feature. 

12.2.6 Check for technology-specific local storage. 

12.2.6.1 Check for Flash local objects using the BetterPrivacy plug-in 
for Firefox. 

12.2.6.2 Check any Silverlight isolated storage in this directory: 

C -. \Users\ {username} \AppData\LocalLow\Microsof t\ 
SilverlightX 

12.2.6.3 Check any use of HTML5 local storage. 

12.3 Check for Weak SSL Ciphers 

12.3.1 If the application uses SSL for any of its communications, use the tool 
THCSSLCheck to list the ciphers and protocols supported. 

12.3.2 If any weak or obsolete ciphers and protocols are supported, a suitably 
positioned attacker may be able to perform an attack to downgrade or 
decipher the SSL communications of an application user, gaining access 
to his sensitive data. 

12.3.3 Some web servers advertise certain weak ciphers and protocols as sup- 
ported but refuse to actually complete a handshake using these if a 
client requests them. This can lead to false positives when you use the 
THCSSLCheck tool. You can use the Opera browser to attempt to per- 
form a complete handshake using specified weak protocols to confirm 
whether these can actually be used to access the application. 

12.4 Check Same-Origin Policy Configuration 

12.4.1 Check for the /crossdomain . xml file. If the application allows unrestricted 
access (by specifying <allow-access-from domain= " * " />), Flash objects 



852 Chapter 21 A Web Application Hacker's Methodology 



from any other site can perform two-way interaction, riding on the ses- 
sions of application users. This would allow all data to be retrieved, and 
any user actions to be performed, by any other domain. 

12.4.2 Check for the /clientaccesspolicy . xml file. Similar to Flash, if the 
<cross-domain-access> configuration is too permissive, other sites 
can perform two-way interaction with the site under assessment. 

12.4.3 Test an application's handling of cross-domain requests using 
XMLHttpRequest by adding an Origin header specifying a different 
domain and examining any Access -Control headers that are returned. 
The security implications of allowing two-way access from any domain, 
or from specified other domains, are the same as those described for the 
Flash cross-domain policy. 

13 Follow Up Any Information Leakage 



13.1 In all your probing of the target application, monitor its responses for 
error messages that may contain useful information about the error's 
cause, the technologies in use, and the application's internal structure 
and functionality. 

13.2 If you receive any unusual error messages, investigate these using stan- 
dard search engines. You can use various advanced search features to 
narrow down your results. For example: 

"unable to retrieve" filetype:php 

13.3 Review the search results, looking both for any discussion about the 
error message and for any other websites in which the same message has 
appeared. Other applications may produce the same message in a more 
verbose context, enabling you to better understand what kind of conditions 
give rise to the error. Use the search engine cache to retrieve examples 
of error messages that no longer appear within the live application. 

13.4 Use Google code search to locate any publicly available code that may 
be responsible for a particular error message. Search for snippets of error 
messages that may be hard-coded into the application's source code. 
You can also use various advanced search features to specify the code 
language and other details, if these are known. For example: 

unable\ to\ retrieve lang:php package :mail 

13.5 If you receive error messages with stack traces containing the names 
of library and third-party code components, search for these names on 
both types of search engine. 





Index 



Absinthe, 322 

absolute URLs, open redirection 
vulnerabilities 
blocking, 544-545 
prefix, 545-546 
"accept known good" approach, 

input, 24 
access 
ASP attackers, 658-660 
ASP.NET API methods 
database, 721 
file, 720 
ASPs and customer, 665-666 
database 
ASP.NET API methods, 721 
Java API methods, 714-715 
Perl language API methods, 

737-738 
PHP API methods, 729-730 
defense mechanisms handling, 
18-21 
authentication, 18-19 
control, 20-21 

session management, 19-20 
Java API methods 

database, 714-715 

file, 713 
Perl language API methods 

database, 737-738 

file, 737 
PHP API methods 

database, 729-730 

file, 727-729 
shared hosting 

attackers, 658-660 



customer, 665-666 
trust relationships in tiered 
architecture, 649 
access controls 
account testing, 267-270 

API methods, 276-277 

HTTP methods, 278 

limited access, 273-276 

multistage function, 271-273 

static resources, 277 
application mapping, 268-269 
attackers, 266-278 

types, 258-260 

usernames and passwords, 
275-276 
back-end components, 357 
broken, 7, 274 
context-dependent, 258 
declarative, 282-283 
defective, 257 
discretionary, 282 
flaws, 284 

hacker's methodology 
insecure access, 823 
limited access, 822-823 
multiple accounts, 822 
requirements, 821 

horizontal, 258 

identifier-based functions, 
261-262 

insecure methods, 265-266 

location-based, 266 

multistage functions, 262-263 
testing, 271-273 

parameter-based, 265-266 

per-user segregation, 274 



platforms, 264-265 

programmatic, 282 

referer-based, 266 

role-based, 282 

security, 278-283 
best practices, 279-280 
central component approach, 
280 

multilayered privilege 

model, 280-283 
pitfalls, 278-279 
static resources, 263-264 

account testing, 277 
unprotected functionality, API 

methods, 260-261 
vertical, 258 

vulnerabilities, 258-266, 276 
application logic flaws, 411 
Access -Control -Al low- 
Origin headers, 528-529 
account activation URLs, 184 
account suspension, 197-198 
account testing, access controls, 
267-270 
API methods, 276-277 
HTTP methods, 278 
limited access, 273-276 
multistage function, 271-273 
static resources, 277 
Achilles proxy, 751 
Action Message Format (AMF), 
135 

Burp Suite, 137 
active scanning, 764-765 
ActiveX controls, 447 

COMRaider, 558 



854 Index A-A 



hacker's methodology, browser 

extensions, 804 
HTML modification, 557 
"safe for scripting" 

registration, 555-557 
vulnerabilities, 555-556 
finding, 556-558 
preventing, 558-559 
administrative functions, web 

applications, 35-36 
administrators 
DBA, 325-326 

defense mechanisms handling 
attackers, alerting, 33-34 

Ajax 
HTML5, 487 

stored XSS in uploaded files 

via, 486-487 
web functionality, 62-63, 384 
Alcon, Wade, 565 
alerts, 33-34 
Allaire JRun, 690-691 
allow_url_include, 729 
AMF. See Action Message 

Format 
ampersand character, batch 

function, 360-361, 363 
Anley, Chris, 218, 322, 634 
anomalous event alerts, 33 
anti-CSRF tokens, 508-509, 
516-517 
XSS defeating, 509-510 
anti-XSS filters, 452 
IE, 748 

AOL AIM Enterprise Gateway 

application, 409 
Apache 
chunked encoding overflow, 
688 

error messages, 628 
mod_isapi, 688 
mod_proxy, 688 
reflected XSS, 442 
Tomcat, 673 
virtual hosting, 683 
API methods 
access controls to, 260-261 

account testing, 276-277 
ASP.NET 

database, 721 

dynamic code execution, 722 

file access, 720 

OS command execution, 

722-723 
sockets, 723 
URL redirection, 723 
user input, 718-719 



Java 

database access, 714-715 
dynamic code execution, 715 
file access, 713 
OS command execution, 

715-716 
potentially dangerous, 

713-716 
sockets, 716 
URL redirection, 716 
Java user input, 712 
JavaScript DOM-based, 740 
Perl language 
database access, 737-738 
dynamic code execution, 738 
file access, 737 
OS command execution, 738 
potentially dangerous, 

736-739 
sockets, 739 
URL redirection, 738 
PHP 

database access, 729-730 
dynamic code execution, 

730-731 
file access, 727-729 
OS command execution, 731 
potentially dangerous, 

727-732 
sockets, 732 

URL redirection, 731-732 
server-side redirection, 392 
SQL injection, 291 
versatility, 358 
Apple iDisk Server, path 

traversal vulnerabilities, 690 
application. See web application 
application architecture. See 

tiered architectures 
application logic flaws 
access controls vulnerabilities, 
411 

attack surface, 405 
audit trail, 429 
authentication, 415-416 
avoiding, 428-429 
beating business limit, 416-417, 
429 

breaking bank, 414-416 
bulk discount cheating, 418, 429 
debugger messages, 424-426 
developers, 429-430 
encryption oracle, 407-408 

"remember me" function, 407 
escaping, 419-420 
financial services, 412-416 
forced browsing, 411 



hacker's methodology 
attack surface, 842 
incomplete input, 843 
multistage functions, 

842-843 
transaction logic, 844 
trust relationships, 844 

hacker's methodology, 

authentication, 811-813 

invalidating input validation, 
420-422 

lessons, 428-429 

login function, 426-427 
race conditions, 427 

nature of, 406 

password change function, 

409- 410 
proceeding to checkout, 

410- 411 
real-world, 406-407 
rolling your own insurance, 

412-413 
search function, 429 

abuse, 422-424 
security, 428 

session management, 429 
shell metacharacters, 419 
source code, 428 
SQL injection, 420-422 
application logs, 262 
application mapping, 73 
access controls, 268-269 
analyzing, 97-113 
key areas, 97-98 
attack surface, 111 
example, 112-113 
Burp Suite, 268 
comparisons, 268-269 
enumerating content and 
functionality, 74-97 
hacker's methodology, 795-798 
debug parameters, 798 
default content, 797 
enumerating identifiers, 

797-798 
hidden content, 796-797 
public information resources, 
796 

tokens to sessions, 818 
visible content, 795-796 
hidden content 
brute-force techniques 

discovering, 81-85 
discovering, 80-93 
inference from published 

content discovering, 

85-89 



Index A -A 855 



public information 

discovering, 89-91 
web server leveraged for 
discovering, 91-93 
hidden parameters, 96-97 
input entry points 
HTTP headers, 100-101 
out-of-band channels, 101 
request parameters, 99 
URL file paths, 98-99 
methodology, 114 
naming schemes, 85-86 
brute-force exercise, 88 
identifying, 87 
path traversal vulnerabilities, 

371 
server-side 
functionality identification, 

106-110 
technology identification, 
101-106 
web application pages versus 
functional paths, 93-96 
application servers. See web 
servers 

application service providers 
(ASPs), 656-657. See also ASP. 
NET; cloud computing 
attackers, 658-665 
access, 658-660 
deliberate backdoor scripts, 

660-661 
between web applications, 
660-663 
financial services, 658 
organization, 658 
securing, 665-667 
component segregation, 667 
customer access, 665-666 
customer functionality 
segregation, 666 
shared, 657-658 
threats, 657 
VPN, 659 
arbitrary input. See user input 
architecture. See tiered 

architectures 
Armstrong, Dave, 505 
The Art of Software Security 
Assessment (Dowd & 
McDonald & Schuh), 634 
ASCII code, 67 

US-ASCII, 464 
Asirra puzzles, Microsoft, 612 
ASP.NET, 54, 103 
API methods 
database, 721 



dynamic code execution, 722 

file access, 720 

OS command execution, 
722-723 

sockets, 723 

URL redirection, 723 

user input, 718-719 
error messages, 628 
OS command injection via, 

360-361 
redirection, 392 

security configuration, 723-724 
session interaction, 719-720 
stack traces, 617 
ViewState 
attackers, 127 
Base64 encoding, 125-126 
Burp Suite, 126 
client-side data transmission, 

124-127 
purpose, 125 
security, 155 
ASPs. See application service 

providers 
. aspx file extension, 107 
Astely, Rick, 541 
attack payloads, XSS, 443-447 
autocomplete, 446 
escalating client-side, 447 
escalation to other pages, 

473-474 
inducing actions, 445-446 
Trojan injection, 444-445 
trust relationship exploitation, 

446-447 
virtual defacement, 443-444 
attack surface 
application logic flaws, 405 
application mapping, 111 

example, 112-113 
hacker's methodology, 

application logic flaws, 
842 

hacker's methodology 
mapping, 800 
attackers. See also specific attacks 
access controls, 266-278 
types, 258-260 
usernames and passwords, 
275-276 
ASP.NET ViewState, 127 
ASPs, 658-665 
access, 658-660 
deliberate backdoor scripts, 

660-661 
between web applications, 
660-663 



browser extensions casino 

component, 134 
CAPTCHA, 198-199 
customized automation, 
610-611 
client-side attacks, 13 
cloud computing, 14, 663-665 
cloned systems, 664 
tokens, 665 
cookie injection methods, 

536-537 
credentials, 171 

defense mechanisms handling, 
30-35 

administrator alerting, 33-34 

audit log maintenance, 31-32 

errors, 30-31 

reacting to, 34-35 
disabled elements, 132-133 
encoding and, 66-67 
forgotten password, 14 
format string vulnerabilities, 
644 

HTTP header injection, 

534-535 
intentions, 13 
login function, 164-165 
MS-SQL databases, 326-327 
multilayered privilege model, 

283 

multistage login function, 188 

MySQL, 328 

network hosts, 561-562 

non-HTTP services, 562-563 

NULL bytes, 23-24 

opaque data, 124 

Oracle databases, 327 

other users, 431-432 

path traversal vulnerabilities 

circumventing obstacles, 
374-377 

successful, 374 

target locations, 370-371 
remote, 427 

session management, 20 
session token scripts, 217 
shared hosting, 658-665 

access, 658-660 

deliberate backdoor scripts, 
660-661 

between web applications, 
660-663 
stored XSS steps, 438-439 
tiered architectures, 648-654 

categories, 648-649 
tokens 

encrypting, 232-233 



856 Index B-B 



meaningful, 212 
URL translation, 396-397 
username, 168 
web application security, 6 
web browsers, 559-568 
websites created by, 448-449 
XMLHttpRequest, 529 
XSS, 251 
attribute delimiters, HTML 

bypassing filters, 461-462 
attribute names, HTML 
bypassing filters, 461 
attribute values, HTML 
bypassing filters, 462 
audit logs 
defense mechanisms handling 
attackers, maintaining, 
31-32 
key events, 32 
poorly protected, 32 
value, 31 
audit trail, 429 
authentication. See also 
access controls; session 
management 
anomalies, 201 

application logic flaws, 415-416 
broken, 7 

brute-force login function, 
162-165 

CAPTCHA, 198-199 

credentials 
incomplete validation, 

180-181 
insecure distribution, 184 
insecure storage, 190-191 
secret handling of, 192-193 
strength, 192 

transmission vulnerability, 
169-171 

validation, 193-195 
CSRF, 507-508 
as defense, 159 

defense mechanisms handling 

access with, 18-19 
design flaws, 161-184 
drop-down menus, 193 
eavesdroppers, 169 
hacker's methodology 
application logic flaws, 

811-813 
credentials, autogenerated, 

809-810 
credentials, unsafe 

distribution, 810-811 
credentials, unsafe 

transmission, 810 
impersonation, 808-809 



insecure web storage, 811 
password guessing, 807 
password quality, 806 
password recovery, 807-808 
"remember me" functions, 
808 

understanding, 805 
username enumeration, 

806-807 
username uniqueness, 809 
vulnerability exploitation for 

unauthorized access, 

813 

HTML forms, 160-161 
HTTP, 50-51 
sessions avoided with, 
208-209 
impersonation, 178-180 
hacker's methodology, 
808-809 
implementation flaws in, 

185-191 
information leakage 

prevention, 195-196 

Egging, 201 
login function 
account suspension, 197-198 
fail-open, 185-186, 194 
multistage, 186-190, 194-195 
verbose failure messages, 
166-169 
monitoring, 201 
notifying, 201 
passwords 
change functionality, 171- 

172, 193 
change functionality misuse, 
199 

forgotten functionality, 

173-175 
predictable initial, 183 
weak, 161-162 
problems with, 19 
"remember me" functions, 
175-176, 193 
hacker's methodology, 808 
security, 191-201 
brute-force attack prevention, 

196-199 
subtleties, 195 
smartcards, 206 
standalone vulnerability 

scanners, 778-779 
technologies, 160-161 
tokens, 160 
usernames 
enumeration, 166-169, 
806-807 



nonunique, 181-182 
predictable, 182-183, 197 
uniqueness, 809 
XSS, 473-474 
autocomplete 
local privacy attacks, 552 
XSS attack payloads, 446 
automation. See customized 
automation 



backdoor password, 178-179 

source code, 708 
backdoor scripts, deliberate, 

660-661 
back-end components. See also 
file inclusion; operating 
system commands; path 
traversal vulnerabilities 
access controls, 357 
data transmission, 357 
e-mail header injection, 

398-399 
HPI, 390 

causes, 393-394 
HPP, 394-395 

server-side HTTP redirection, 
390-392 
exploiting, 391-392 
SMTP injection, 397-402 
flaws, 400-401 
preventing, 402 
SOAP injection, 386-388 
banking application, 387-388 
error messages, 388 
finding and exploiting, 389 
preventing, 27, 390 
URL translation attacks, 
396-397 
back-end request injection, 841 
backslash character, escaping 

with, 419 
backtick character, encapsulating 

function of, 363 
banking application 
multistage function, 263 
per-page tokens, 252-253 
SOAP injection, 387-388 
banner grabbing, 101 
Base64 encoding, 69 

ASP.NET ViewState, 125-126 
basic authentication, 50-51 
batch queries, MS-SQL 

databases, 317 
beating business limit, 
application logic flaws, 
416-417, 429 



Index C-C 857 



BeEF, 565-566 

bit flipper, Burp Intruder, 593 
encrypting tokens, 228-231 
black-box code review, 702-703 
blacklist-based filters, 23-24 

XSS, 451-452 
blind SQL injection, 626 
blocked characters, filters, 

311-312 
blog applications, input, 22 
Boolean conditions, UNION 

operator, 329 
Boolean flag, 107 
boundary validation, input, 

25-28, 313 
breaking bank, application logic 

flaws, 414-416 
browser extensions. See also 

Flash; Java; Silverlight 
casino component, 133-134 

attackers, 134 
Chrome, 750 

client-side control of user input 

with, 133-153 
data transmission interception, 
135-139 
obstacles, 138-139 
serialized data, 136-138 
debugger attached to, 151-152 
decompiling, 139-150 
bytecode, 139-141 
bytecode obfuscation, 

144-146 
Java applets example, 146-150 
JavaScript manipulating 

original bytecode, 144 
source code, 142-144 
Firefox, 750 

hacker's methodology, 802-804 

ActiveX controls, 804 

debugger, 803-804 

decompiling, 802-803 
native client components, 153 
same-origin policy, 525-527 

Flash, 525-526 

Java, 527 

Silverlight, 526-527 
targeting approaches, 135 
technologies, 65 
browsers. See web browsers 
browsing history 
JavaScript stealing, 560 
local privacy attacks, 552 
brute-force techniques 
application mapping naming 

schemes exercise, 88 
authentication security 
preventing, 196-199 



hidden content, 81-85 
login function, 162-165 
passwords in wiki, 424 

buffer overflow 
detecting, 639-640 
hacker's methodology, 837-838 
heap overflows, 635-636 
off-by-one vulnerabilities, 

636-638 
software, 687 
source code, 709 
stack overflows, 634-635 
uncontrolled, 639 
URL length, 639 

bulk discount cheating, 

application logic flaws, 418, 
429 

Burp Intruder, 82-84, 86 
bit flipper, 593 

encrypting tokens, 228-231 
"character frobber," 593 
customized automation, 
590-602 
data harvesting, 598-600 
enumerating identifiers, 

594-597 
fuzzing, 600-602 
payloads 
choosing, 592-594 
positioning, 591-592 
predictable tokens, 213-214 
response analysis, 594 
sniper attack, 592 
Unicode encoding, 375 
user agent strings, 100 
Burp Proxy, 754-755 
Burp Repeater, 473, 681, 766 
Burp Scanner, 764-765 
Burp Sequencer, 767 
auto analyze setting, 223 
token randomness testing, 
219-221 
Burp Spider, 74-76, 80 
Burp Suite 
AMF, 137 

application mapping, 268 
ASP.NET ViewState, 126 
CA certificate, 758-759 
"change request method" 
command, 474-475 
Comparer, 167 
Content Discovery, 88-89 
DSer, 136-137 

"request in browser," 272-273 
session-handling mechanisms, 
603-609 
cookie jar, 603-604 
request macros, 604-606 



session-handling rules, 

606-609 
session-handling tracer, 609 
business limit, application logic 

flaws, 416-417, 429 
business logic exploitation, 259 
bytecode 
decompiling browser 
extensions, 139-141 
JavaScript manipulation, 144 
obfuscation, 144-146 
downloading, 140 
Flash, 141 
Java, 141 
Silverlight, 141 
source code recompiling 
within browser, 142-143 
outside browser, 143 
URL, 140 

c 

CA certificate, Burp Suite, 

758-759 
callbacks, function, 520 
canonicalization 
input, 28-29 

web server software, 689-694 
CAPTCHA 
attackers, 198-199 
customized automation, 

610- 611 
authentication, 198-199 
bugs, 610-611 
customized automation, 

610-612 
attackers, 610-611 
automatically solving, 

611- 612 
humans solving, 612 

drones, 612 
Cascading Style Sheets (CSS) 
dynamically evaluated styles, 
459 

font-family property, 

518-519 
injection, cross-domain data 

capture, 517-519 
web functionality, 60-61 
casino component, browser 
extensions, 133-134 
attackers, 134 
CBC. See cipher block chaining 
CGI query, 735-736 
chaining 
CBC 

encrypting tokens, 227-233 
PKC # 5 padding, 227-233 



858 Index C-C 



XSS, 450-451 
"change request method" 

command, 474-475 
"character frobber," Burp 

Intruder, 593 
checked exceptions, 30 
checkout, application logic flaws, 

410-411 
CheckQuantity applet, 141 
Chrome, 750 
chrooted file system 
path traversal vulnerabilities, 

380-381 
UNIX, 381 
cipher block chaining (CBC) 
encrypting tokens, 227-233 
PKC # 5 padding, 686-687 
ciphertext, 224-226 
. class files, 141 
ClearedFunds element, 

387-388 
cleartext, passwords, 190-191 
clickjacking, 511. See also user 

interface redress attacks 
client components, native, 153 
client-side 
attacks, 13 

data transmission, 118-127 
ASP.NET ViewState, 

124-127 
for developers, 118 
hacker's methodology, 801 
hidden HTML forms, 118-120 
HTTP cookies, 121 
opaque data, 123-124 
Ref errer header, 122 
security, 154-156 
URL parameters, 121-122 

hacker's methodology, data 
transmission, 801 

HPP, 548-550 

information disclosure leaks, 
629 

injection, 531-550 

SQL, 547-548 
JavaScript, validation with, 

130-131, 156 
security, 431-432 
session token hijacking, 

243-244 
SQL injection, 547-548 
SSL certification, 138 
user input controlled by, 117 
browser extensions, 133-153 
hacker's methodology, 

801-802 
HTML forms, 127-133 



validation myths, 155-156 
web functionality, 57-65 

Ajax, 62-63, 384 

browser extension 
technologies, 65 

CSS, 60-61 

DOM, 62 

forms, 58-60 

HTML, 58 

HTML5, 64-65 

hyperlinks, 58 

JavaScript, 61 

JSON, 63 

same-origin policy, 64 
VBScript, 61 
XSS attack payloads escalating, 
447 

cloned systems, 664 
cloud computing 
attackers, 14, 663-665 
cloned systems, 664 
tokens, 665 
defense mechanism, 664 
feature-first approach, 664-665 
loss of control in, 663-664 
management tool migration 

to, 664 
web applications, 5 
web storage, 665 
CMS. See content management 

system 
code browsing tools, 743 
code injection, 288 
code review. See source code, 
review 

commands. See operating system 

commands 
comments 

MySQL, 303-304, 312 

source code, 710-711 

SQL, 312 
Comparer, Burp Suite, 167 
compiled applications. See native 

client components 
concealed sequences, 213-215 
concurrent logins, 250 
conditional errors, SQL injection, 

320-322 
conjunctive queries filters, 350 

LDAP injection, 352-353 
CONNECT method, 682, 755 
content 

enumerating and functionality, 

74-97 
hidden 
brute-force techniques 
discovering, 81-85 



discovering, 80-93 
hacker's methodology, 

application mapping, 

796-797 
inference from published 

content discovering, 

85-89 
Nikto discovering, 93 
public information 

discovering, 89-91 
user-directed spidering 

discovering, 81-83 
web server leveraged for 

discovering, 91-93 
Wikto discovering, 92-93 
web server and default, 92, 
671-677 
debug functionality, 671-672 
hacker's methodology, 847 
JMX, 674-676 

powerful functions, 673-674 
sample functionality, 672-673 
Content Discovery, Burp Suite, 
88-89 

content management system 
(CMS), 77 

web servers, 92 
Content-Length header, 42 

POST request, 581 
Content-Type header, 136, 138, 

476, 478, 525-526 
context-dependent, access 

controls, 258 
Cookie header, 41, 47 
cookie injection 

attacker methods, 536-537 

session fixation, 537-540 
cookie jar, Burp Suite, 603-604 
cookies 

arbitrary, 537 

attributes, 47 

domain restrictions, 245-247 
hacker's methodology, 820-821 
HTTP, 19, 47 
client-side data transmission, 
121 

session management tokens, 
207-208, 234-236 
HTTP header injection, 533 
login function, 163 
path restrictions, 247-248 
persistent, 550 
reflected XSS, 437-438 
RemembeMe, 407-408 
"remember me" functions, 

175-176 
ScreenName, 407-408 



Index C-C 859 



session management, liberal 


escalation to other pages, 


cookies, 437-438 


scope, 244-248 


473-474 


defensive filters, 455-456 


XSS exploiting via, 475 


inducing actions, 445-446 


delivering, 448-449 


COPY method, 679 


Trojan injection, 444-445 


DOM XSS converted from, 


count ( ) function, 348 


trust relationship 


472-473 


credentials 


exploitation, 446-447 


exploiting, 435-438, 474 


attackers, 171 


virtual defacement, 443-444 


finding and exploiting, 


authentication vulnerability, 


attackers, 251 


452-481 


169-171 


authentication, 473-474 


hacker's methodology, 


e-mail containing, 184 


chaining, 450-451 


829-830 


hacker's methodology, 


CSRF defeating anti-CSRF 


HTML limitations, 495-496 


authentication 


tokens with, 510-511 


IE, 435 


autogenerated, 809-810 


database error messages, 620 


input insertion, 495 


unsafe distribution, 810-811 


defense, 28 


input validation, 492-493 


unsafe transmission, 810 


delivery mechanisms, 447-451 


length limits, 471-473 


incomplete validation, 180-181 


in-band, 449-450 


output validation, 493-495 


insecure distribution, 184 


out-of-band, 450 


preventing, 492-496 


insecure storage, 190-191 


DOM-based, 440-442 


"remember me" function, 437 


secret handling of, 192-193 


delivering, 448-449 


sanitizing filters, 468-471 


strength, 192 


finding and exploiting, 


signature-based filters, 


validation, 193-195 


487-491 


455-456 


web server and default, 


input validation, 497 


steps, 436-437 


670-671 


output validation, 497-498 


stored XSS compared to, 


hacker's methodology, 846 


preventing, 496-498 


439-440 


cross-domain data capture, 


reflected XSS converted into, 


user input testing, 453 


515-516 


472-473 


user input testing to 


CSS injection, 517-519 


steps, 441 


introduce script, 


Firefox, 521 


escaping, 420 


454-455 


HTML injection, 516-517 


exploits 


security evolution, 433 


JavaScript hijacking, 519-520 


cookies, 475 


session token vulnerabilities, 


E4X, 523-524 


delivering, 473-481 


243-244 


function callbacks, 520 


JavaScript executed within 


source code, 704-705 


JSON, 521 


XML responses, 


stored, 438-440 


preventing, 524 


478-479 


attacker steps, 438-439 


variable assignment, 522 


nonstandard request and 


delivering, 449-450 


proxy services, 529-531 


response content, 


e-mail testing, 483-484 


cross-domain requests 


476-479 


finding and exploiting, 


JSON, 477 


Ref errer header, 475-476 


481-487 


XMLHttpRequest, 528-529 


XML requests sent cross- 


HTML limitations, 495-496 


XSS sending XML, 477-478 


domain, 477-478 


input insertion, 495 


/crossdomain.xml, 525-526 


filters 


input validation, 492-493 


cross-site request forgery (CSRF), 


anti-, 452, 748 


MySpace, 442-443, 446 


8, 244, 504-511 


blacklist-based, 451-452 


output validation, 493-495 


anti-CSRF tokens, 508-509, 


IE, 479-481 


preventing, 492-496 


516-517 


web browsers, 479-481 


reflected XSS compared to, 


XSS defeating, 510-511 


HTML tag pairs, 422 


439-440 


authentication, 507-508 


IE filter, 479-481 


search function, 439 


flaws 


JavaScript, 436-438 


uploaded files testing, 


exploiting, 506-507 


non-HTTP services, 562-563 


484-487 


preventing, 508-510 


NULL bytes, 460 


vulnerabilities 


real-world, 505 


POST request changed to GET 


identifying, 451-452 


hacker's methodology, 820 


request, 474-475 


low-risk, 451 


session management, 251 


prevalence, 432 


varieties, 433-442 


cross-site scripting (XSS), 8 


preventing, 492-498 


XSS Shell, 566 


attack payloads, 443-447 


real-world, 442-443 


cryptographic algorithms, 687 


autocomplete, 446 


reflected, 434-438 


CSRF. See cross-site request 


escalating client-side, 447 


Apache, 442 


forgery 



860 Index D-D 



CSS. See Cascading Style Sheets 
Curl, 788 

custom development, web 

applications, 10 
custom encoding, path traversal 

vulnerabilities, 377-378 
customized automation 
barriers to, 602-612 
Burp Intruder, 590-602 
data harvesting attack, 

598-600 
enumerating identifiers 

attack, 594-597 
fuzzing attack, 600-602 
CAPTCHA puzzles, 610-612 
attackers, 610-611 
automatically solving, 

611-612 
humans solving, 612 
data harvesting, 572 
basic approach, 584-586 
Burp Intruder, 598-600 
causes, 583-584 
JAttack, 585-586 
uses, 584 
efficiency, 571 
enumerating identifiers, 
572-583 
basic approach, 574 
Burp Intruder, 594-597 
detecting hits, 574-576 
examples, 573 
HTTP status code, 574 
JAttack, 577-583 
Location header, 575 
response body, 575 
response length, 574-575 
scripting, 576-577 
Set-Cookie header, 575 
time delays, 575-576 
fuzzing, 572-573 
Burp Intruder, 600-602 
JAttack, 588-590 
objective, 586-587 
strings, 587 
session-handling mechanisms, 

602-609 
standalone vulnerability 

scanners, 780-781 
uses, 572-573 
Cygwin environment, 577 

D 

DAC. See discretionary access 
control 

data capture. See cross-domain 
data capture 



data harvesting, 572 
basic approach, 584-586 
Burp Intruder, 598-600 
causes, 583-584 
JAttack, 585-586 
uses, 584 
data stores. See also Extensible 
Markup Language; 
Lightweight Directory 
Access Protocol; Structured 
Query Language 
accessing, 288-289 
NoSQL, 342-343 
privilege level, 287 
web applications relying on, 
287 

data transmission. See also user 
input 

back-end components, 357 
browser extensions 

intercepting, 135-139 

obstacles, 138-139 

serialized data, 136-138 
client-side, 118-127 

ASP.NET ViewState, 
124-127 

for developers, 118 

hacker's methodology, 801 

hidden HTML forms, 118-120 

HTTP cookies, 121 

opaque data, 123-124 

Ref errer header, 122 

security, 154-156 

URL parameters, 121-122 
lazy load approach, 626 
opaque, 123-124 

attackers, 124 
database administrator (DBA), 

325-326 
The Database Hacker's Handbook, 

326 
databases 
access 

ASP.NET API methods, 721 
Java API methods, 714-715 
Perl language API methods, 
737-738 

code components 
dangerous, 742 
SQL injection, 741-742 

error messages, 619-622 
encryption oracle, 620-622 
information disclosure, 

619-620 
XSS in, 620 

escalation attacks, 
319, 325-328 

fingerprinting, 303-304 



inf ormation_schema, 

309-310 
MS-SQL 

attackers, 326-327 

automated exploitation, 330 

batch queries, 317 

default lockdown, 326-327 

error messages, 334-338 

out-of-band channels, 317 

syntax, 332-334 

WAITFOR command, 322-323 
Oracle 

attackers, 327 

llg, 318 

error messages, 334-338 
out-of-band channels, 

317-318 
syntax, 332-334 
time delays, 323-324 
UNION operator, 307-308 
searchable and sortable, 

321-322 
stored procedures, 339 
Davtest, 680 

DBA. See database administrator 
debuggers 
browser extensions attaching, 

151-152 
error messages, 425-426, 
618-619 
common, 619 
hacker's methodology, 

application mapping, 798 
hacker's methodology, browser 

extensions, 803-804 
Java, 151-152 
messages 
application logic flaws, 

424-426 
verbose, 425 
Silverlight, 152 
web server, 671-672 
declarative access controls, 

282-283 
decompiling 
browser extensions, 139-150 
bytecode, 139-141 
bytecode obfuscation, 

144-146 
Java applets example, 146-150 
JavaScript manipulating 

original bytecode, 144 
source code, 142-144 
hacker's methodology, browser 

extensions, 802-803 
Jad, Java, 148-150 
decryption algorithms, 650 
default content 



Index E-E 861 



hacker's methodology, 

application mapping, 797 
web server, 671-677 
hacker's methodology, 847 
default credentials, web server, 
670-671 
hacker's methodology, 846 
default lockdown, MS-SQL 

databases, 326-327 
defense in depth 
SQL injection, 342 
tiered architectures, 656 
web server software, 696-697 
defense mechanisms. See also 
security 
access 
authentication, 18-19 
control, 20-21 

session management, 19-20 
attackers, 30-35 
administrator alerting, 33-34 
audit log maintenance, 31-32 
errors, 30-31 
reacting to, 34-35 
elements, 17-18 
input, 21-29 

approaches to, 23-25 
user access, 18-21 
defensive filters, reflected XSS, 

455-456 
DELETE method, 679 
DELETE statements, 297-298 
deliberate backdoor scripts, 

660-661 
developers 
application logic flaws, 429-430 
client-side data transmission, 
118 

HTML encoding mistakes, 
494-495 

web applications security, 3 
digest authentication, 50-51 
directory listings, web servers, 
677-679 

Allaire JRun, 690-691 
directory names, 105 
disabled elements 

attackers, 132-133 

HTML forms, 131-133 
discount cheating, application 

logic flaws, 418, 429 
discretionary access control 

(DAC), 282 
disjunctive queries filters, 350 

LDAP injection, 351 
.311 files, 141 
DNS rebinding, 563-564 
doctype element, 384-385 



document object model (DOM), 
61 

hacker's methodology, 849-850 
JavaScript, 440 
JavaScript API methods, 740 
web functionality, 62 
XSS, 440-442 
delivering, 448-449 
finding and exploiting, 

487-491 
input validation, 497 
output validation, 497-498 
preventing, 496-498 
reflected XSS converted to, 

472-473 
steps, 441 
DocumentRoot directive, 683 
DOM. See document object 
model 

domain restriction cookies, 

245-247 
DOMTracer, 488 
dot character, script code 

bypassing filters alternatives 

to, 466 
"dot-dot-slash" sequence, 

369. See also path traversal 

vulnerabilities 
Dowd, Mark, 634 
downloading 
bytecode, 140 

encrypting tokens, 231-232 
drop-down menus, 

authentication, 193 
DSer, Burp Suite, 136-137 
Dump Servlet, Jetty, 672 
dynamic code execution 
ASP.NET API methods, 722 
Java API methods, 715 
OS command injection, 362 

vulnerabilities, 366-367 
Perl language API methods, 
738 

PHP API methods, 730-731 
dynamically constructed strings, 
466 

E 

E4X. See ECMAScript for XML 
Eagle, Chris, 634 
eavesdroppers 

authentication, 169 

session tokens, 234 
eBay, 505 

ECB ciphers. See electronic 

cookbook ciphers 
Echo Mirage, 139 



ECMAScript for XML (E4X), 463 

JavaScript hijacking, 523-524 
edit parameter, 107 
Edwards, Dean, 471 
EJB. See Enterprise Java Bean 
electronic cookbook ciphers 

(ECB ciphers), 224-226 
e-mail 

account activation URLs, 184 
credentials sent in, 184 
forged, 448 

header injection, 398-399 
stored XSS testing, 483-484 
as username, 167, 196 
encoding 
Apache chunked overflow, 688 
attackers and, 66-67 
Base64, 69 
ASP.NET ViewState, 
125-126 
custom, path traversal 

vulnerabilities, 377-378 
hex, 69-70 
HTML, 68-69 

developer mistakes, 494-495 
script code bypassing filters, 
468 

Unicode, 67-68 

Burp Intruder, 375 
URL, 67 

SQL injection, 300-301 

truncating, 378 
web server software, 689-694 
encrypting 
.NET, 686 

"remember me" function, 177 

tokens, 223-233 
attackers, 232-233 
Burp Intruder bit flipper, 

228-231 
CBC, 227-233 
downloading, 231-232 
ECB ciphers, 224-226 
"reveal" encryption oracle, 
232 

encryption oracle 
application logic flaws, 407-408 
"remember me" function, 407 
database error messages, 

620-622 
"reveal," encrypting tokens, 
232 

Enterprise Java Bean (EJB), 53 
enterprise resource planning 

software (ERP), 4 
enumerating identifiers, 572-583 

basic approach, 574 

Burp Intruder, 594-597 



862 Index ■ F-F 



detecting hits, 574-576 
examples, 573 
hacker's methodology, 

application mapping, 
797-798 
HTTP status code, 574 
JAttack, 577-583 
Location header, 575 
response body, 575 
response length, 574-575 
scripting, 576-577 
Set-Cookie header, 575 
time delays, 575-576 
ERR See enterprise resource 

planning software 
error messages 
Apache, 628 
ASRNET, 628 
database, 619-622 

encryption oracle, 620-622 

information disclosure, 
619-620 
databases, XSS in, 620 
debugger, 425-426, 618-619 

common, 619 
dynamically generated, 434 
engineering informative, 

624-625 
exploiting, 615-625 
generic, 628 
IE, 622 

information disclosure, 
615-625 
generic, 628 
Java, 628 
keywords, 622 
Microsoft IIS, 628 
MS-SQL databases, 334-338 
MySQL, 334-338 
ODBC, 624 

Oracle databases, 334-338 
public information, 623 
published content, 625 
script, 616-617 
search engines, 623 
server, 619-622 
SOAP injection, 388 
source code, 623 
SQL injection, 334-338 
stack traces, 617-618 
UNION operator, 306 
VBScript, 616 
verbose, 30-31, 624 
errors 

conditional, SQL injection, 

320-322 
defense mechanisms handling 

attackers and, 30-31 



unhandled, 30-31 
escaping 

application logic flaws, 419-420 

with backslash character, 419 

JavaScript, script code 

bypassing filters, 465-466 

XSS, 420 
Etag string, 128-129 
eval function, 362, 722 

script code bypassing filters 
alternatives to, 466 
event handlers 

HTML5, 458 

script code in HTML with, 
457-458 
Expires header, 42 
Extensible Markup Language 
(XML), 56. See also Simple 
Object Access Protocol; XML 
Path Language 
E4X, 463 

injection, 383-390 

XXE, 384-386, 841 
interpreting, 387 
XSS exploits 
JavaScript in, 478-479 
sending cross-domain, 
477-478 
Extract Grep function, 598 

F 

fail-open login function, 185-186, 
194 

failure messages, verbose, 

166-169 
file extensions, 102-105 
file inclusion 
hacker's methodology, 835-836 
local, 382 
remote, 381-382 

flaw testing, 383 
static resources, 382 
vulnerabilities, 381-383 
finding, 382-383 
PHP, 381-382 
file path manipulation, 368-383. 
See also path traversal 
vulnerabilities 
filters 

blocked characters, 311-312 
conjunctive queries, 350 

LDAP injection, 352-353 
disjunctive queries, 350 

LDAP injection, 351 
exploiting defective, 313 
HTML bypassing, 459-465 

attribute delimiters, 461-462 



attribute names, 461 

attribute values, 462 

character sets, 464-465 

tag brackets, 462-464 

tag name, 460-461 
input, path traversal 

vulnerabilities, 374-377 
LDAP, 350 

Oracle PL/SQL Exclusion List 

bypassing, 692-694 
reflected XSS 
defensive, 455-456 
sanitizing, 468-471 
signature-based, 456-457 
sanitizing, reflected XSS, 

468-471 
script code bypassing, 465-468 
dot character alternatives, 
466 

dynamically constructed 

strings, 466 
encoding, 468 
eval function alternatives, 

466 

JavaScript escaping, 465-466 
multiple technique 

combination, 466-467 
VBScript, 467 
VBScript and JavaScript, 
467-468 
simple match conditions, 350 
SQL injection bypassing, 
311-313 

XSS 
anti-, 452, 748 
blacklist-based, 451-452 
IE, 479-481 

web browsers, 479-481 
financial services 

application logic flaws, 412-416 

ASPs, 658 
fingerprinting databases, SQL 

injection, 303-304 
Firebug, 785 
Firefox, 459 

browser extensions, 750 

cross-domain data capture, 521 

Firesheep tool, 234 

hacker's toolkit, 749-750 

Ref errer header, 239 
Firesheep tool, Firefox, 234 
firewalls, 12 

alerts, 33 

WAFs, NULL bytes, 460 
first-order XSS. See reflected XSS 
500 Internal Server 
Error, 49 

brute-force techniques, 85 



Index C-H 863 



503 Service Unavailable, 
49 

Flash, 134-135 
bytecode, 141 

/crossdomain . xml, 525-526 
LSOs, 553 

same-origin policy, 525-526 
serialized data, 137-138 
font-family property, 518-519 
forced browsing, application 

logic flaws, 411 
forgotten password, 584 

attackers using, 14 
format string vulnerabilities 
attackers, 644 
causes, 643 
detecting, 644 
hacker's methodology, 838 
source code, 710 
forms 
HTML, 58-59 
authentication, 160-161 
client-side control of user 
input with, 127-133 
client-side data transmission 

with hidden, 118-120 
disabled elements, 131-133 
intercepting proxy 

modifying hidden, 
119-120 
length limits, 128-129 
script-based validation, 
129-131 
web functionality, 58-60 

400 Bad Request, 48 
brute-force techniques, 84 

401 Unauthorized, 48 
brute-force techniques, 84-85 

403 Forbidden, 49 
brute-force techniques, 84-85 

404 Not Found, 49 

405 Method Not Allowed, 49 

413 Request Entity Too 
Large, 49 

414 Request URI Too Long, 
49 

framebusting, UI redress 

attacks, 514-515 
function callbacks, JavaScript 

hijacking, 520 
functional paths, web 

application pages versus, 

93-96 
functionality. See web 

functionality 
function-specific input 

vulnerabilities, hacker's 

methodology, 836-841 



fuzzing, 572-573 
Burp Intruder, 600-602 
hacker's methodology, 

parameter, 824-827 
integrated testing suites, 

762-763 
JAttack, 588-590 
objective, 586-587 
strings, 587 

G 

general headers, 45 
generic error messages, 628 
GET method, 42 

purpose, 264 
GET request, 40 

XSS converting, 474-475 
getCurrentUserRoles 

method, 261 
GIFAR files, 485-486 
Google, 89 

Omitted Results, 90 

querying, 90 
Google Translate (GT), 530-531 
Gray Hat Hacking (Eagle & Harris 

& Harper & Ness), 634 
GT. See Google Translate 

H 

hacker's methodology 

access controls 
insecure access, 823 
limited access, 822-823 
multiple accounts, 822 
requirements, 821 

analysis 
attack surface mapping, 800 
data entry points, 799 
functionality, 798-799 
technologies, 799-800 

application logic flaws 
attack surface, 842 
incomplete input, 843 
multistage functions, 

842-843 
transaction logic, 844 
trust relationships, 844 

application mapping, 795-798 
debug parameters, 798 
default content, 797 
enumerating identifiers, 

797-798 
hidden content, 796-797 
public information resources, 
796 

of tokens to sessions, 818 
visible content, 795-796 



authentication 
application logic flaws, 

811-813 
credentials, autogenerated, 

809-810 
credentials, unsafe 

distribution, 810-811 
credentials, unsafe 

transmission, 810 
impersonation, 808-809 
insecure web storage, 811 
password guessing, 807 
password quality, 806 
password recovery, 807-808 
"remember me" functions, 

808 

understanding, 805 
username enumeration, 

806-807 
username uniqueness, 809 
vulnerability exploitation for 

unauthorized access, 

813 

back-end request injection, 841 
browser extensions, 802-804 

ActiveX controls, 804 

debugger, 803-804 

decompiling, 802-803 
buffer overflow, 837-838 
client-side 

data transmission, 801 

user input, 801-802 
cookie scope, 820-821 
CSRF, 820 
DOM, 849-850 
file inclusion, 835-836 
format string vulnerabilities, 
838 

fuzzing parameters, 824-827 
guidelines, 793-794 
HTTP header injection, 830 
information leakage, 852 
input-based vulnerabilities, 

824-836 
function-specific, 836-841 
integer vulnerabilities, 838 
LDAP injection, 839-840 
local privacy attacks, 850-851 
miscellaneous checks, 849-852 
native software bugs, 837-838 
open redirection 

vulnerabilities, 830-831 
OS command injection, 

832- 833 

path traversal vulnerabilities, 

833- 835 
reflected XSS, 829-830 
same-origin policy, 851-852 



864 Index H-H 



script injection, 835 
session management 
token insecure transmission, 
817 

token system log disclosure, 

817-818 
tokens tested for meaning, 

815-816 
tokens tested for 

predictability, 816-817 
understanding, 814-815 
sessions 
fixation, 819 
terminating, 818-819 
shared hosting, 845-846 
SMTP injection, 836-837 
SOAP injection, 839 
SQL injection, 827-829 
stored procedures, 831-832 
weak SSL ciphers, 851 
web servers, 846-849 
dangerous HTTP methods, 
847 

default content, 847 
default credentials, 846 
native software bugs, 848 
proxy server functionality, 
847 

virtual hosting, 847-848 

WAFs, 848-849 
work areas, 791-793 
XPath injection, 840-841 
XXE injection, 841 
hacker's toolkit, 747 
custom scripts, 786-789 

Curl, 788 

Netcat, 788-789 

Stunnel, 789 

Wget, 788 
Firebug, 785 
Hydra, 785-786 
integrated testing suites, 
751-773 

components, 752-769 

types, 751 
Nikto, 785 

web browsers, 748-750 

Chrome, 750 

Firefox, 749-750 

IE, 748-749 
Wikto, 785 
Hammad, Sherief, 322 
Harper, Allen, 634 
Harris, Shon, 634 
HEAD functions, 43 
head method, 265 
heap overflows, 635-636 
Heasman, John, 634 
hex encoding, 69-70 



hidden content 
discovering, 80-93 
brute-force techniques, 81-85 
inference from published 

content, 85-89 
Nikto, 93 

public information, 89-91 
user-directed spidering, 
81-83 

web server leveraged for, 

91-93 
Wikto, 92-93 
hacker's methodology, 

application mapping, 
796-797 
hidden HTML form fields 
client-side data transmission 

with, 118-120 
intercepting proxy modifying, 
119-120 

hidden parameters, application 

mapping, 96-97 
hijacking 
JavaScript, 519-520 

E4X, 523-524 

function callbacks, 520 

JSON, 521 

preventing, 524 

variable assignment, 522 
sessions, 436 
Holyfield, Brian, 138 
horizontal access controls, 

258 

horizontal privilege escalation, 

259, 416 
Host header, 41 
hosting. See shared hosting 
HP OpenView, 359 
HPI. See HTTP parameter 

injection 
HPP See HTTP parameter 

pollution 
HTML. See hypertext markup 

language 
HTML5 
Ajax, 487 

event handlers, 458 
local privacy attacks, 554 
same-origin policy, 528-529 
script pseudo-protocols, 458 
web functionality, 64-65 

HTTP. See hypertext transfer 
protocol 

HTTP header injection 
causes, 531-532 
cookies, 533 
exploiting, 532-535 
attackers, 534-535 
hacker's methodology, 830 



HTTP response splitting, 

534-535 
input validation, 536 
preventing, 536 
HTTP parameter injection (HPI), 
390 

causes, 393-394 

HPP, 394-395 
HTTP parameter pollution (HPP) 

client-side, 548-550 

HPI, 394-395 
HTTPRECON, 102 
HTTPS, 49 

integrated testing suites, 
intercepting proxies, 
755-758 

login function, 170 

man-in-the-middle attacks, 
566-568 

proxy servers, 50 

session tokens, 234-236, 250 
HTTPWatch tool, IE, 748 
Hydra, 785-786 

hyperlinks, web functionality, 58 
hypertext markup language 
(HTML). See also HTML5 
ActiveX controls modification, 
557 

bypassing filters, 459-465 
attribute delimiters, 461-462 
attribute names, 461 
attribute values, 462 
character sets, 464-465 
tag brackets, 462-464 
tag name, 460-461 
encoding, 68-69 

developer mistakes, 494-495 
forms, 58-59 
authentication, 160-161 
client-side control of user 
input with, 127-133 
client-side data transmission 

with hidden, 118-120 
disabled elements, 131-133 
intercepting proxy 

modifying hidden, 
119-120 
length limits, 128-129 
script-based validation, 
129-131 
injection, cross-domain data 

capture, 516-517 
reflected XSS limiting, 495-496 
script code introduced in 
dynamically evaluated CSS 

styles, 459 
event handlers, 457-458 
script pseudo-protocols, 458 
scripttags, 457 



Index 14 865 



stored XSS limiting, 495-496 
tag pairs, XSS, 422 
web functionality with, 58 
hypertext transfer protocol 

(HTTP). See also HTTP header 
injection 
access controls testing, 278 
authentication, 50-51 
sessions avoided with, 
208-209 
benefits, 5 
cookies, 19, 47 
client-side data transmission, 
121 

session management tokens, 
207-208, 234-236 
fingerprinting, 102 
hacker's methodology, web 

servers, 847 
headers 
application mapping, input 

entry points, 100-101 
general, 45 
request, 45-46 
response, 46 

security assumptions, 123 
HPI, 390 

causes, 393-394 
HPP, 394-395 

client-side, 548-550 
man-in-the-middle attacks, 

566-568 
messages, 40-42 
methods, 42-44 
origins, 39 
proxy servers, 49-50 
requests, 40-41 

dissecting, 107-108 

input sources, 52 

URL, 40, 42 
responses, 41-42 

splitting, 534-535 
server-side redirection, 
390-392 

exploiting, 391-392 
SSL and, 49 
status codes, 48-49 

enumerating identifiers, 574 
TCP protocol, 40 
hypothesis testing, statistical, 

219-222 

I 

ID field, 295 
IDA Pro, 153 
iDefense, 558 
identifier-based functions 
access controls, 261-262 



application logs, 262 
identifiers. See enumerating 

identifiers 
IE. See Internet Explorer 
IEWatch tool, 79, 748 
If-Modif ied-Since, 128-129 
If-None-Match, 128-129 
i frame, 511-515 
IIS, Microsoft 

error messages, 628 

ISAPI extensions, 688 

path traversal vulnerabilities, 
691-692 

impersonation, authentication, 
178-180 

hacker's methodology, 808-809 
in-band delivery, XSS, 449-450 
inducing actions, 501 
request forgery 
CSRF, 8, 244, 251, 504-511 
OSRF, 502-503 
UI redress attacks, 508, 511-515 
basic form, 511-513 
framebusting, 514-515 
mobile devices, 515 
preventing, 515 
variations, 513 
XSS attack payloads, 445-446 
inference 
information disclosure, 

626-627 
search engines, 626 
SQL injection, 319-324 
infinite loops, 29 
information disclosure 
error messages, 615-625 

generic, 628 
inference, 626-627 
leaks 
client-side, 629 
preventing, 627-629 
protecting, 628-629 
published content, 625 
information leakage, 8 
authentication preventing, 

195-196 
hacker's methodology, 852 
information disclosure 
client-side, 629 
preventing, 627-629 
inf ormation_schema, 309-310 
initialization vector (IV), 685 
injection 
back-end request, 841 
client-side, 531-550 

SQL, 547-548 
code, 288 
cookie 

attacker methods, 536-537 



session fixation, 537-540 
CSS, cross-domain data 

capture, 517-519 
e-mail header, 398-399 
HPI, 390 

causes, 393-394 
HTML, cross-domain data 

capture, 516-517 
HTTP header 

attackers exploiting, 534-535 

causes, 531-532 

cookies, 533 

exploiting, 532-535 

hacker's methodology, 830 

HTTP response splitting, 
534-535 

input validation, 536 

output validation, 536 

preventing, 536 
interpreted language, 288-290 
LDAP, 349-354 

conjunctive queries filters, 
352-353 

exploiting, 351-353 

flaws, 353-354 

hacker's methodology, 
839-840 

preventing, 354 

vulnerabilities, 350-351 
login function bypassed, 

288-290 
NoSQL, 342-344 

MongoDB, 343-344 
OS commands, 358-368 

ASP.net, 360-361 

dynamic code execution, 362 

dynamic code execution, 

vulnerabilities, 366-367 

flaws, 363-366 

hacker's methodology, 
832-833 

metacharacters, 420 

Perl language, 358-360 

preventing, 367-368 

shell metacharacters, 363, 365 

source code, 708 

spaces, 366 

time delay, 363-364 
script 

hacker's methodology, 835 
preventing vulnerabilities, 
368 

SMTP, 397-402 

flaws, 400-401 

hacker's methodology, 
836-837 

preventing, 402 
SOAP, 386-388 

banking application, 387-388 



866 Index ■ J-J 



error messages, 388 
finding and exploiting, 389 
hacker's methodology, 839 
preventing, 27, 390 
SQL, 7, 14 
advanced exploitation, 

314- 324 
API methods, 291 
application logic flaws, 

420-422 
blind, 626 
bugs, 298-302 
client-side, 547-548 
column name, 301-302 
conditional errors, 320-322 
database code components, 

741-742 
defense in depth, 342 
DELETE statements, 297-298 
double hyphen, 293 
error messages, 334-338 
exploitation tools, 328-331 
filter bypassing, 311-313 
fingerprinting databases, 

303-304 
hacker's methodology, 

827-829 
inference, 319-324 
input validation 

circumvented, 312 
INSERT statements, 295-296 
JavaScript errors, 299 
numeric data, 299-301, 

315- 316 

ORDER BY clause, 301-302 
out-of-band channel, 316-319 
parameterized queries, 

339-341 
preventing, 27, 338-342 
query structure, 301-302 
second-order, 313-314 
SELECT statements, 294-295 
source code, 705-706 
string data, 298-299 
syntax, 332-334 
time delays, 322-324 
UNION operator, 304-308 
UNION operator data 

extraction, 308-311 
UPDATE statements, 296-297 
URL encoding, 300-301 
vulnerability exploitation, 
292-294 

Trojan, XSS attack payloads, 
444-445 

XML, 383-390 
XXE, 384-386, 841 

XPath, 344-349 



blind, 347-348 
flaws, 348-349 
hacker's methodology, 

840-841 
informed, 346-347 
preventing, 349 
input. See also user input 
"accept known good" 

approach, 24 
application mapping, entry 
points for 
HTTP headers, 100-101 
out-of-band channels, 101 
request parameters, 99 
URL file paths, 98-99 
blog applications, 22 
boundary validation, 25-28, 
313 

canonicalization, 28-29 
defense mechanisms, 21-29 

approaches to, 23-25 
filters, path traversal 

vulnerabilities, 374-377 
hacker's methodology, 

application logic flaws 

and incomplete, 843 
insertion, stored XSS, reflected 

XSS eliminating 

dangerous, 495 
multistep validation, 28-29 
"reject known bad" approach, 

23-24 

safe data handling approach, 
25 

sanitization approach, 24-25 

semantic checks, 25 

validation, 21-22, 313 
application logic flaws 

invalidating, 420-422 
circumventing, 312 
DOM-based XSS, 497 
HTTP header injection, 536 
problems, 26 

stored XSS, reflected XSS, 
492-493 
varieties, 21-23 
input-based vulnerabilities, 
hacker's methodology, 
824-836 
function-specific, 836-841 
INSERT statements 
SQL injection, 295-296 
WHERE clause, 295 
insurance, application logic 

flaws, 412-413 
integer vulnerabilities 
causes, 640 
detecting, 642-643 



hacker's methodology, 838 
overflows, 640-641 
signedness errors, 641-642 
source code, 709-710 
integrated testing suites 
fuzzing, 762-763 
hacker's toolkit, 751-773 
components, 752-769 
types, 751 
intercepting proxies 
alternatives, 771-773 
common features, 758-759 
HTTPS, 755-758 
web browser configuration, 
752-755 
manual request tools, 765-767 
shared functions and utilities, 

768-769 
shared token analyzers, 767 
Tamper Data, 772 
TamperlE, 772-773 
vulnerability scanners, 764-765 

standalone, 773-784 
web spidering, 760-762 
work flow, 769-771 
intercepting proxies 
evolution, 751 
integrated testing suites 
alternatives, 771-773 
common features, 758-759 
HTTPS, 755-758 
web browser configuration, 
752-755 
Internet. See World Wide Web 
Internet Explorer (IE), 239, 459 
anti-XSS filters, 748 
error messages, 622 
HTTPWatch tool, 748 
IEWatch tool, 79, 748 
reflected XSS, 435 
TamperlE, 772-773 
userData, 554 
web application hacker's 

toolkit, 748-749 
XSS filter, 479-481 
Internet forums, public 

information, 91 
interpreted language injection, 

288-290 
IP address availability, 100 
IV. See initialization vector 

J 

Jad, Java, 141 

decompiling, 148-150 
. j ad files, 148-150 
. j ar files, 141 
JAttack 



Index K-L 867 



data harvesting, 585-586 
enumerating identifiers, 

577-583 
extract function, 598 
fuzzing, 588-590 
strength, 590 
Java 
API methods 

database access, 714-715 

dynamic code execution, 715 

file access, 713 

OS command execution, 
715-716 

potentially dangerous, 
713-716 

sockets, 716 

URL redirection, 716 
applets, 134 

decompiling browser 

extensions, 146-150 
bytecode, 141 
debuggers, 151-152 
error messages, 628 
Jad, 141 

decompiling, 148-150 
same-origin policy, 527 
security configuring, 716-717 
serialized data, 136-137 
session interaction, 712-713 
terminology, 53 
tiered architectures, 648 
user input, 711-712 

API methods, 712 
web container, 53 
web functionality, 53-54 
Java Servlet, 53 

Java Virtual Machine (JVM), 134 
web server software 

vulnerabilities, 690 
java . io . File, 713 
j ava . net . Socket, 716 
JavaScript 
browsing history stolen with, 
560 

client-side, validation with, 

130-131, 156 
decompiling browser 

extensions, original 

bytecode manipulation, 

144 
DOM, 440 

DOM-based API methods, 740 
escaping, script code 

bypassing filters, 465-466 
hijacking, 519-520 

E4X, 523-524 

function callbacks, 520 

JSON, 521 



preventing, 524 
variable assignment, 522 
$js function, 344 
length limits, 471 
logging keystrokes, 560 
open redirection 

vulnerabilities, 546 
port scanning, 561, 566 
script code bypassing filters 

using VBScript and, 

467-468 
SQL injection, errors in, 299 
third-party applications 

currently used, 560-561 
web functionality, 61 
XSS, 436-438 

XSS exploits executing, in XML 
responses, 478-479 
JavaScript Object Notation 
(JSON) 
cross-domain requests, 
477 

JavaScript hijacking, 521 

web functionality, 63 
JavaSnoop, 151-152 
JBoss Application Server, 

674-676 
Jetty, 218 

Dump Servlet, 672 
Jitko worm, 530-531 
$ j s function, JavaScript, 344 
JMX, 674-676 
JRun, Allaire, 690-691 
JSON. See JavaScript Object 

Notation 
. j sp file extension, 107 
JSwat, 151-152 

JVM. See Java Virtual Machine 

K 

Kamkar, Samy, 219 
keystrokes, logging, 560 
Klein, Amit, 248 

L 

LAMP server, 650-651, 666 
languages. See interpreted 

language 
lazy load approach, data 

transmission, 626 
LDAP. See Lightweight Directory 

Access Protocol 
leaks. See information leakage 
length limits 
JavaScript, 471 
reflected XSS, 471-473 
Ley, Jim, 444 



Lightweight Directory Access 
Protocol (LDAP) 
filters, 350 
injection, 349-354 
conjunctive queries filters, 

352-353 
disjunctive queries filters, 351 
exploiting, 351-353 
flaws, 353-354 
hacker's methodology, 

839-840 
preventing, 354 
vulnerabilities, 350-351 
uses, 349-350 
Linder, Felix, 634 
Litchfield, David, 320, 327, 693 
LOAD_FILE command, 328 
local file inclusion, 382 

tiered architectures, 652-654 
local privacy attacks 
autocomplete, 552 
browsing history, 552 
Flash LSOs, 553 
hacker's methodology, 850-851 
HTML5, 554 
IE userData, 554 
persistent cookies, 550 
preventing, 554-555 
Silverlight Isolated Storage, 553 
testing, 550 
Local Shared Objects (LSOs), 553 
Location header, 531-532 

enumerating identifiers, 575 
location-based access controls, 
266 

logging keystrokes, 560 
logic. See application logic flaws 
login function, 18-19, 160 
account suspension, 197-198 
application logic flaws, 426-427 

race conditions, 427 
attackers, 164-165 
authentication 
brute-forcible, 162-165 
verbose failure messages, 
166-169 
concurrent, 250 
cookies, 163 
fail-open, 185-186, 194 
HTTPS, 170 

injection bypassing, 288-290 
multistage, 186-190, 194-195 

attackers, 188 

common myth, 187 

purpose, 186-187 

random questions, 189-190, 
194-195 
secondary challenge, 173, 200 



868 Index M-0 



secret questions, 189 
session management, 206 

tokens, 539-540 
timing differences, 168-169 
username enumeration, 
166-169 
logout function, session 

management, 242, 250 
logs. See system log disclosure, 

session tokens 
LSOs. See Local Shared Objects 

M 

macros, request, 604-606 
magic_quotes-gpc directive, 
734 

mail ( ) command, 398-399 
mail services. See e-mail; SMTP 

injection 
man-in-the-middle attacks, 

566-568 

manual request tools, integrated 

testing suites, 765-767 
mapping. See application 

mapping 
Mavituna, Ferruh, 566 
McDonald, John, 634 
meaningful token attackers, 212 
memory management, web 

server software, 687-689 
metacharacters, OS command 

injection, 420. See also shell 

metacharacters 
Microsoft. See also Internet 

Explorer 
Asirra puzzles, 612 
IIS 

error messages, 628 
ISAPI extensions, 688 
path traversal vulnerabilities, 
691-692 
security, 431-432 
SiteLock Active Template 
Library, 559 
mobile devices 
applications, 4 
UI redress attacks, 515 
mod_isapi, Apache, 688 
mod_proxy, Apache, 688 
MongoDB, NoSQL injection, 

343-344 
MOVE method, 679-680 
MS-SQL databases 
attackers, 326-327 
automated exploitation, 330 
batch queries, 317 
default lockdown, 326-327 



error messages, 334-338 
out-of-band channels, 317 
syntax, 332-334 
WAITFOR command, 322-323 
multistage functions 
access controls, 262-263 

testing, 271-273 
banking application, 263 
hacker's methodology, 

application logic flaws, 
842-843 
login, 186-190, 194 
attackers, 188 
common myth, 187 
purpose, 186-187 
random questions, 189-190, 
194-195 
multistep validation, input, 
28-29 

MySpace, stored XSS, 442-443, 
446 

MySQL 
attackers, 328 
comments, 303-304, 312 
double hyphen, 293 
error messages, 334-338 
out-of-band channels, 319 
path traversal vulnerabilities, 
651 

sleep function, 323 

syntax, 332-334 

tiered architectures extracting, 

650-652 
UDFs, 328 

N 

naming schemes 
application mapping, 85-86 
brute-force exercise, 88 
identifying, 87 
static resources, 87 
native client components, 153 
native compiled applications 
buffer overflow, 634-640 
examples, 633 

format string vulnerabilities, 

643-644 
integer vulnerabilities, 640-643 
testing for, 633-634 
native software bugs 
hacker's methodology, 837-838 

web servers, 848 
source code, 709-710 
NBFS. See .NET Binary Format 

for SOAP 
negative price method, 120 
Ness, Jonathan, 634 



.NET 

encryption, 686 
padding oracle, 685-687 
.NET Binary Format for SOAP 

(NBFS), 138 
Netcat, 788-789 
NETGEAR router, 562 
network disclosure, session 

tokens, 234-237 
network hosts, attackers, 561-562 
network perimeter, web 

application security and new, 

12-14 

nextPayload method, 578 
NGSSof tware, 640 
Nikto 

hacker's toolkit, 785 

hidden content, 93 

maximizing effectiveness, 797 
non-HTTP services, 562-563 
NoSQL 

advantages, 343 

data stores, 342-343 

injection, 342-344 
MongoDB, 343-344 
notNetgear function, 562 
nslookup command, 365 
NTLM protocol, 50 
NULL bytes 

attackers, 23-24 

WAFs, 460 

XSS, 460 
NULL value, 306-307 
numeric data 

limits, 417 

SQL injection into, 299-301, 
315-316 

o 

obfuscation 
bytecode, decompiling browser 

extensions, 144-146 
custom schemes, 109 
OCR. See optical character 

recognition 
ODBC. See open database 

connectivity 
off-by-one vulnerabilities, 

636-638 
OllyDbg, 153 

Omitted Results, Google, 90 

100 Continue, 48 

on-site request forgery (OSRF), 

502-503 
onsubmit attributes, 130 
opaque data 
attackers, 124 



Index P-P 869 



client-side data transmission, 
123-124 
open database connectivity 

(ODBC), 624 
open redirection vulnerabilities 
causes, 540-541 
finding and exploiting, 

542-546 
hacker's methodology, 830-831 
JavaScript, 546 
preventing, 546-547 
rickrolling attacks, 541 
source code, 707-708 
URLs, 542 
absolute prefix, 545-546 
blocking absolute, 544-545 
user input, 543-544 
OpenLDAR 352 

operating system commands (OS 
commands) 
ASRNET API methods, 

722-723 
injection, 358-368 
ASP.net, 360-361 
dynamic code execution, 
362 

dynamic code execution, 

vulnerabilities, 366-367 

flaws, 363-366 

hacker's methodology, 
832-833 

metacharacters, 420 

Perl language, 358-360 

preventing, 367-368 

shell metacharacters, 363, 365 

source code, 708 

spaces, 366 

time delay, 363-364 
Java API methods, 715-716 
Perl language API methods, 
738 

PHP API methods, 731 
optical character recognition 

(OCR), 611 
OPTIONS functions, 43 
OPTIONS method, 679-680 
OPTIONS request, 528 
Oracle 
databases 

attackers, 327 

llg, 318 

error messages, 334-338 
out-of-band channels, 

317-318 
syntax, 332-334 
time delays, 323-324 
UNION operator, 307-308 



PL/SQL Exclusion List, 
676-677 
web server software filter 
bypass, 692-694 
web server, 676-677 
The Oracle Hacker's Handbook 

(Litchfield), 693 
oracles. See encryption oracle 
ORDER BY clause, 295 

SQL injection, 301-302 
Origin headers, 528-529 
OS commands. See operating 

system commands 
OSRF. See on-site request forgery 
other user attackers, 431-432 
out-of-band channels 
application mapping, input 

entry points, 101 
MS-SQL databases, 317 
MySQL, 319 

Oracle databases, 317-318 
SQL injection, 316-319 
unavailable, 319 

out-of-band delivery, XSS, 450 

output validation 
DOM-based XSS, 497-498 
HTTP header injection, 536 
stored XSS, reflected XSS, 
493-495 

P 

padding oracle 
attack, 626 
.NET, 685-687 
pageid parameter, 598 
parameter-based access controls, 

265-266 
parameterized queries 
provisos, 341 
SQL injection, 339-341 
parameters 
application mapping, input 

entry points, 99 
hidden, application mapping, 

96-97 
URL, client-side data 

transmission, 121-122 
parseResponse method, 585, 
589 

passive scanning, 764-765 
passwords 
access controls attackers 
harvesting, 275-276 
backdoor, 178-179 
source code, 708 
brute-force techniques for 
wiki, 424 



change functionality, 171-172, 
193 

application logic flaws, 
409-410 

misuse, 199 

username, 172 
cleartext storage, 190-191 
forgotten, 14, 584 

functionality, 173-175 
guessing, 160 

techniques, 163-164 
hacker's methodology, 
authentication 

guessing, 807 

quality, 806 

recovery function, 807-808 
hints, 174, 200 
predictable initial, 183 
real-world, 163 
recovery 

challenges, 173-174 

hacker's methodology, 

authentication, 807-808 

hints, 200 

misuse, 199-200 

secondary challenge, 200 

time-limited URLs, 174-175 
requirements, 192 
resetting, 175 
system-generated, 192 
truncated, 180-181 
weak, 161-162 
path restriction cookies, 247-248 
path traversal vulnerabilities 
Apple iDisk Server, 690 
application mapping, 371 
attackers 

circumventing obstacles, 
374-377 

successful, 374 

targets, 370-371 
causes, 368-369 
enrooted file system, 380-381 
custom encoding, 377-378 
detecting, 372-374 

initial testing, 372 
exploiting, 379 
finding, 370-378 
hacker's methodology, 833-835 
input filters, 374-377 
Microsoft IIS, 691-692 
MySQL, 651 
preventing, 379-381 
source code, 706-707 
subtlety, 370 

UNIX compared to Windows, 
374 



870 Index Q-R 



user input, 379-380 
Payment Card Industry (PCI), 7 
Perl language 
API methods 
database access, 737-738 
dynamic code execution, 738 
file access, 737 
OS command execution, 738 
potentially dangerous, 

736-739 
sockets, 739 
URL redirection, 738 
eval function, 362 
OS command injection via, 

358-360 
security configuration, 739-740 
session interaction, 736 
shell metacharacters, 360 
user input, 735-736 
per-page tokens, 252-253 
persistent cookies, 550 
phishing attacks, 541, 707 
PHP 
API methods 
database access, 729-730 
dynamic code execution, 

730-731 
file access, 727-729 
OS command execution, 731 
potentially dangerous, 

727-732 
sockets, 732 

URL redirection, 731-732 
eval function, 362 
file inclusion vulnerabilities, 

381-382 
mail ( ) command, 398-399 
safe mode, 666 

security configuration, 732-735 
magic_quotes-gpc 

directive, 734 
regis ter_globals 

directive, 733 
saf e_mode directive, 
733-734 
session interaction, 727 
tiered architectures, 653-654 
user input, 724-727 
web functionality, 54-55 
. php file extension, 108 
phpinf o . php, 672 
ping command, 364 
PKC # 5 padding, 685 

CBC, 686-687 
Plain Old Java Object (POJO), 
53 



PL/SQL Exclusion List, Oracle, 
676-677 
web server software filter 
bypass, 692-694 
POJO. See Plain Old Java Object 
port scanning, Java Script, 561, 
566 

POST method, 43, 192 

purpose, 264 
POST request 
Content -Length header, 581 
XSS converting, 474-475 
PostgreSQL, 323 
Pragma header, 42 
predictable initial passwords, 

183-184 
predictable tokens, 213-223 
Burp Intruder, 213-214 
concealed sequences, 213-215 
time dependency, 215-217 
weak random number 
generation, 218-219 
testing quality, 219-223 
preg_replace function, 730 
prepared statements, 339-341 
privacy attacks. See local privacy 

attacks 
privilege 
data stores, 287 
DBA, 325-326 
escalation 
horizontal, 258, 416 
vertical, 258, 416 
multilayered model 
access controls security, 

280-283 
attackers, 283 
privs field, 295 
proceeding to checkout, 
application logic flaws, 
410-411 
programmatic access controls, 
282 

PROPFIND method, 679 
proxy history records, 769-771 
proxy servers. See also 
intercepting proxies 
hacker's methodology, web 

servers, 847 
hidden HTML form 

modification with 
intercepting, 119-120 
HTTP, 49-50 
HTTPS, 50 
invisible, 138 
web servers as, 682-683 



proxy services 

cross-domain data capture, 
529-531 

GT, 530-531 

Jitko worm, 530-531 
public information 

error messages, 623 

hacker's methodology, 

application mapping, 796 

hidden content discovery with, 
89-91 

Internet forums, 91 

search engines for, 89 

web archives for, 89-90 
published content 

error messages, 625 

hidden content discovery with 
inference from, 85-89 

information disclosure, 625 
PUT functions, 43 
PUT method, 679-680 

Q 

quant i ty parameter, 

restricting, 128 
queries 
CGI, 735-736 
conjunctive filters, 350 

LDAP injection, 352-353 
disjunctive filters, 350 
LDAP injection, 351 
parameterized 
provisos, 341 
SQL injection, 339-341 
search engines, 90 
SELECT queries, UNION 
operator, 304-305 
structure, SQL injection, 
301-302 

R 

race conditions, 427 
Rails 1.0, 55 

RBAC. See role-based access 

control 
real-world 
application logic flaws, 406-407 
CSRF flaw, 505 
passwords, 163 
XSS, 442-443 
recompiling, source code to 
bytecode 
within browser, 

142-143 
outside browser, 143 



Index S-S 871 



redirection attacks. See open 

redirection vulnerabilities 
referer-based access controls, 266 
Ref errer header, 41-42 
client-side data transmission, 

122 
Firefox, 239 

XSS exploiting via, 475-476 
reflected XSS, 434-438 

Apache, 442 

cookies, 437-438 

delivering, 448-449 

DOM XSS converted from, 
472-473 

exploiting, 435-438, 474 

filters 
defensive, 455-456 
sanitizing, 468-471 
signature-based, 455-456 

finding and exploiting, 452-481 

hacker's methodology, 829-830 

IE, 435 

length limits, 471-473 

preventing, 492-496 
HTML limitations, 495-496 
input insertion, 495 
input validation, 492-493 
output validation, 493-495 

"remember me" function, 437 

steps, 436-437 

stored XSS compared to, 
439-440 

user input testing, 453 
script introduction, 454-455 
register_globals directive, 
733 

"reject known bad" approach, 

input, 23-24 
RemembeMe cookie, 407-408 
"remember me" functions 

application logic flaws, 

encryption oracle, 407 

authentication, 175-176, 193 
hacker's methodology, 808 

cookies, 175-176 

encrypting, 177 

reflected XSS, 437 
remote attackers, 427 
remote black-box testing, 427 
remote file inclusion, 381-382 

flaw testing, 383 
remoting, 70 

representational state transfer 
(REST), URLs, 44-45 
spidering, 74-75 
request forgery 



CSRF, 8, 244, 504-511 
anti-CSRF tokens, 508-509, 

516-517 
authentication, 507-508 
exploiting flaws, 506-507 
hacker's methodology, 820 
preventing flaws, 508-510 
real-world flaws, 505 
session management, 251 
XSS defeating anti-CSRF 
tokens, 510-511 
OSRF, 502-503 

request headers, 45-46 

"request in browser," Burp Suite, 
272-273 

request macros, Burp Suite, 
604-606 

response headers, 46 

REST. See representational state 
transfer 

reverse strokejacking, 560 

rickrolling attacks, 541 

Rios, Billy, 485 

robots . txt, 74 

role-based access control 
(RBAC), 282 

rolling your own insurance, 
application logic flaws, 
412-413 

Ruby on Rails (Ruby), 55 
WEBrick, 690 

s 

safe data handling approach, 

input, 25 
"safe for scripting" registration, 

ActiveX controls, 555-557 
saf e_mode directive, 733-734 
same-origin policy, 524-525 
browser extensions, 525-527 

Flash, 525-526 

Java, 527 

Silverlight, 526-527 
hacker's methodology, 851-852 
HTML5, 528-529 
web functionality, 64 
sanitization approach, input, 

24-25 

sanitizing filters, 468-471 
scanning. See vulnerability 

scanners 
Schuh, Justin, 634 
ScreenName cookie, 407-408 
scripts. See also cross-site 

scripting 



deliberate backdoor, 660-661 
enumerating identifiers, 

576-577 
error messages, 616-617 
hacker's toolkit custom, 
786-789 
Curl, 788 
Netcat, 788-789 
Stunnel, 789 
Wget, 788 
HTML form validation, 

129-131 
injection 
hacker's methodology, 835 
preventing vulnerabilities, 
368 

reflected XSS user input testing 

to introduce, 454-455 
session token attacker, 217 
script code 
bypassing filters, 465-468 
dot character alternatives, 
466 

dynamically constructed 

strings, 466 
encoding, 468 
eval function alternatives, 

466 

JavaScript escaping, 465-466 
multiple technique 

combination, 466-467 
VBScript, 467 
VBScript and JavaScript, 
467-468 
HTML introducing 
dynamically evaluated CSS 

styles, 459 
event handlers, 457-458 
script pseudo-protocols, 458 
scripttags, 457 
script pseudo-protocols, 458 
search engines 
error messages, 623 
inference, 626 
public information, 89 
queries, 90 
search function 
application logic flaws, 422- 

424, 429 
stored XSS, 439 
SEARCH method, 679 
secondary challenge 
login function, 173, 200 
password recovery, 200 
second-order SQL injection, 
313-314 



872 Index S-S 



second-order XSS. See stored XSS 
secret questions, login function, 
189 

Secure Socket Layer (SSL) 
client-side certification, 138 
communication protection, 192 
hacker's methodology check 

for weak ciphers, 851 
HTTP tunneled over, 49 
security, 7-8 
session tokens, 233 
vulnerabilities of, 8 
security. See also defense 
mechanisms 
access controls, 278-283 
best practices, 279-280 
central component approach, 
280 

multilayered privilege 

model, 280-283 
pitfalls, 278-279 
application logic flaws, 428 
ASP.NET 
configuration, 723-724 
ViewState, 155 
ASPs, 665-667 
component segregation, 667 
customer access, 665-666 
customer functionality 
segregation, 666 
authentication, 191-201 
brute-force attack prevention, 

196-199 
subtleties, 195 
client-side, 431-432 
client-side data transmission, 
154-156 
logging and alerting, 156 
validation, 155 
evolution, 432 
hardening, 695-696 
HTTP headers and 

assumptions with, 123 
Java configuration, 716-717 
media focus on, 432 
Microsoft, 431-432 
myths, 433 
PCI standards, 7 
Perl language configuration, 

739-740 
PHP configuration, 732-735 
magi c_quo t e s - gp c 

directive, 734 
register_globals 

directive, 733 
saf e_mode directive, 
733-734 
questions, 650 



reputation, 1 

session management, 248-254 
shared hosting, 665-667 
component segregation, 667 
customer access, 665-666 
customer functionality 
segregation, 666 
SSL, 7-8 

tiered architectures, 654-656 
time and resources impacting, 
11 

token generation, 210 
underdeveloped awareness 
of, 10 

web application, 1, 6-15 
attackers, 6 

developer understanding, 3 
future, 14-15 
key factors, 10-12 
new network perimeter for, 
12-14 

user input threatening, 9-10 
vulnerabilities, 7-8 
web server 
configuration, 684 
software, 695-697 
website evolution and, 2 
XSS, evolution, 433 
SELECT NULL value, UNION 

operator, 306-307 
SELECT queries, UNION operator, 

304-305 
SELECT statements 
SQL injection, 294-295 
WHERE clause, 321 
self-registration, usernames, 

182, 196 
semantic checks, input, 25 
semicolon character, batch 

function, 363 
serialization, 70 
serialized data 
browser extensions 

intercepting data 
transmission, handling, 
136-138 
Java, 136-137 
Flash, 137-138 
Silverlight, 138 
server error messages, 619-622 
Server header, 42 
server-executable files, 382 
servers. See web servers 
server-side 
API redirection, 392 
functionality 
application mapping 

identifying, 106-110 



ASP.NET, 54, 103 
dissecting requests, 107-108 
Java, 53-54 
PHP, 54-55 
Ruby on Rails, 55 
SQL, 55-56 

web application behavior 

extrapolation, 109-110 
web application behavior 

isolation, 110 
web services, 56-57 
XML, 56 
HTTP redirection, 390-392 

exploiting, 391-392 
technologies 
application mapping 

identifying, 101-106 
banner grabbing, 101 
directory names, 105 
file extensions, 102-105 
HTTP fingerprinting, 102 
session tokens, 105 
third-party code 

components, 105 

sessions 
ASP.NET, 719-720 
fixation 
cookie injection, 537-540 
finding and exploiting, 

539-540 
preventing, 540 
steps, 537-538 
hacker's methodology 
fixation, 819 
terminating, 818-819 
hacker's methodology, 

application mapping, 
tokens to, 818 
hijacking, 436 
HTTP authentication 

alternative to, 208-209 
Java, 712-713 
Perl language, 736 
PHP, 727 

standalone vulnerability 
scanners handling, 
778-779 
state information managed 

without, 209 
termination, 241-243 

reactive, 253-254 
web functionality, 66 
session management. See also 
access controls 
alerts, 253 

application logic flaws, 429 
attackers, 20 

cookies, liberal scope, 244-248 



Index S-S 873 



CSRF, 251 

defense mechanisms handling 

access with, 19-20 
duration, 241-243 
hacker's methodology 
token insecure transmission, 
817 

token system log disclosure, 
817-818 

tokens tested for meaning, 
815-816 

tokens tested for 

predictability, 816-817 

understanding, 814-815 
logging, 253 
login function, 206 
logout function, 242, 250 
monitoring, 253 
security, 248-254 
state information, 206-209 
tokens 

algorithm generating, 249 

attacker scripts, 217 

client-side exposure to 

hijacking of, 243-244 

concealed sequences, 213-215 

eavesdroppers, 234 

encrypting, 223-233 

HTTP cookies, 207-208, 
234-236 

HTTPS, 234-236, 250 

life cycle protection, 250-253 

login function, 539-540 

meaningful, 210-212 

network disclosure, 234-237 

per-page, 252-253 

predictable, 213-223 

server-side technology, 105 

SSL, 233 

strength, 248-249 
system log disclosure, 

237-239 
time dependency, 215-217 
transmitting, 538 
URL transmission, 250 
in URLs, 237-238 
vulnerable mapping of, 

240-241 
weak random number 

generation, 218-219 
weak random number 

quality testing, 219-223 
weakness in generating, 

210-233 
weakness in handling, 

233-248 
XSS vulnerabilities, 243-244 
uses, 205 



session riding. See request 
forgery 

session-handling mechanisms 
Burp Suite 
cookie jar, 603-604 
request macros, 604-606 
session-handling rules, 

606-609 
session-handling tracer, 609 
supporting, 603-609 
customized automation, 
602-609 

session-handling rules, 606-609 
session-handling tracer, 609 
SessionID parameter, 590 
Set-Cookie header, 42, 47, 242, 
244-245, 531 
enumerating identifiers, 575 
setstring method, 340 
shared hosting, 656-657. See also 
cloud computing 
attackers, 658-665 
access, 658-660 
deliberate backdoor scripts, 

660-661 
between web applications, 
660-663 
hacker's methodology, 845-846 
securing, 665-667 
component segregation, 667 
customer access, 665-666 
customer functionality 
segregation, 666 
threats, 657 
virtual hosting, 657 
shared token analyzers, 

integrated testing suites, 767 
shared usernames, 181 
shell metacharacters, 359-360 
application logic flaws, 419 
OS command injection, 363, 
365 

Perl language, 360 

types, 363 
The Shellcoder's Handbook (Anley 

& Heasman & Linder), 634 
Shift-JIS character set, 464-465 
shutdown command, 315 
signature-based filters, reflected 

XSS, 456-457 
signedness errors, 641-642 
Silverlight, 135 

bytecode, 141 

debuggers, 152 

Isolated Storage, 553 

same-origin policy, 526-527 

serialized data, 138 

Spy, 152 



simple match conditions filter, 
350 

Simple Object Access Protocol 
(SOAP), 57 
functions, 386 
injection, 386-388 
banking application, 387-388 
error messages, 388 
finding and exploiting, 389 
hacker's methodology, 839 
preventing, 27, 390 
NBFS, 138 
site map records, 769-771 
SiteLock Active Template 
Library, Microsoft, 559 
sleep function, MySQL, 323 
smartcards, authentication, 206 
SMTP injection, 397-402 
flaws, 400-401 

hacker's methodology, 836-837 
preventing, 402 
sniper attack, Burp Intruder, 592 
SOAP. See Simple Object Access 

Protocol 
sockets 
ASP.NET API methods, 

723 
Java, 716 

Perl language API methods, 
739 

PHP API methods, 732 
source code 
application logic flaws, 428 
backdoor password, 708 
browsing, 743 
buffer overflow, 709 
bytecode recompiling 

within browser, 142-143 

outside browser, 143 
comments, 710-711 
decompiling browser 

extensions, 142-144 
error messages, 623 
format string vulnerabilities, 
710 

integer vulnerabilities, 709-710 
native software bugs, 709-710 
open redirection 

vulnerabilities, 707-708 
OS command injection, 708 
path traversal vulnerabilities, 

706-707 
review 
approaches, 702-704 
black-box versus white-box, 

702-703 
methodology, 703-704 
situations, 701 



874 Index T-T 



signatures of common 

vulnerabilities, 704-711 
SQL injection, 705-706 
XSS, 704-705 
spidering 
REST URLs, 74-75 
user-directed, 77-80 
benefits, 77 

hidden content discovery 

with, 81-83 
web compared to, 79 
web, 74-77 
authentication, 76 
integrated testing suites, 

760-762 
user-directed spidering 
compared to, 79 
SQL. See Structured Query 

Language 
SQLMap, 322 

sql-shell option, 330-331 
SQLzoo.net, 292 
SSL. See Secure Socket Layer 
stack overflows, 634-635 
stack traces 
ASP.NET, 617 
error messages, 617-618 
standalone vulnerability 
scanners, 773-784 
automated versus user- 
directed, 784 
customized automation, 

780-781 
dangerous effects, 779 
individuating functionality, 

779-780 
limitations, 776-777 
products, 781-782 
technical challenges, 778-781 
authentication and session 
handling, 778-779 
using, 783-784 
vulnerabilities detected, 
774-776 

vulnerabilities undetected, 775 
state information 

session management, 206-209 

without sessions, 209 

web functionality, 66 
static resources 

access controls, 263-264 
account testing, 277 

file inclusion, 382 

naming schemes, 87 
static tokens, 240 
statistical hypothesis testing, 

219-222 
status codes, HTTP, 48-49 



enumerating identifiers, 574 
storage. See web storage, cloud 

computing 
stored procedures 

databases, 339 

hacker's methodology, 831-832 
stored XSS, 438-440 
attacker steps, 438-439 
delivering, 449-450 
e-mail testing, 483-484 
finding and exploiting, 481-487 
MySpace, 442-443, 446 
preventing, 492-496 
HTML limitations, 495-496 
input insertion, 495 
input validation, 492-493 
output validation, 493-495 
reflected XSS compared to, 

439-440 
search function, 439 
uploaded files testing, 484-487 
Ajax, 486-487 
GIFAR files, 485-486 
string data 
dynamically constructed, 
script code bypassing 
filters, 466 
manipulation, 316 
SQL injection into, 298-299 
string-length ( ) function, 
348 

strncpy function, 642 
strokejacking, 511. See also user 

interface redress attacks 
reverse, 560 
Structured Query Language 

(SQL) 

client-side injection, 547-548 

comments, 312 

injection, 7, 14 
advanced exploitation, 

314-324 
API methods, 291 
application logic flaws, 

420-422 
blind, 626 
bugs, 298-302 
client-side, 547-548 
column name, 301-302 
conditional errors, 320-322 
database code components, 

741-742 
defense in depth, 342 
DELETE statements, 297-298 
double hyphen, 293 
error messages, 334-338 
exploitation tools, 328-331 
filter bypassing, 311-313 



fingerprinting databases, 

303-304 
hacker's methodology, 

827-829 
inference, 319-324 
input validation 

circumvented, 312 
INSERT statements, 295-296 
JavaScript errors, 299 
numeric data, 299-301, 

315-316 
ORDER BY clause, 301-302 
out-of-band channel, 316-319 
parameterized queries, 

339-341 
preventing, 27, 338-342 
query structure, 301-302 
second-order, 313-314 
SELECT statements, 294-295 
source code, 705-706 
string data, 298-299 
syntax, 332-334 
time delays, 322-324 
UNION operator, 304-308 
UNION operator data 

extraction, 308-311 
UPDATE statements, 296-297 
URL encoding, 300-301 
vulnerability exploitation, 

292-294 
web functionality, 55-56 
structured tokens, 210-212 
Stunnel, 789 

SUBSTR(ING) functions, 324 
suspension of account, 197-198 
. swf files, 141 
syntactic validation, 25 
system log disclosure 
hacker's methodology, session 

management, 817-818 
session tokens, 237-239 
vulnerabilities, 238 

T 

tag brackets, HTML bypassing 

filters, 462-464 
tag name, HTML bypassing 

filters, 460-461 
scripttags, 457 
Tamper Data, 772 
TamperlE, 772-773 
TCP protocol, HTTP using, 40 
testing. See account testing; 

hacker's methodology; 

hacker's toolkit; statistical 

hypothesis testing 
third-party applications, 560-561 



Index U-U 875 



301 Moved Permanently, 48 
3 02 Found, 48 

brute-force techniques, 84 
3 04 Not Modified, 48 
tiered architectures, 647 
attacks, 648-654 

categories, 648-649 
component segregation, 

655-656 
defense in depth, 656 
Java, 648 
layers, 648 
PHP, 653-654 
securing, 654-656 
subverting, 650-654 
decryption algorithms, 650 
local file inclusion executing 

commands, 652-654 
MySQL extraction, 650-652 
trust relationships, 649-650 
access, 649 
minimize, 654-655 
time 
delays 
enumerating identifiers, 

575-576 
Oracle databases, 323-324 
OS command injection, 

363-364 
SQL injection, 322-324 
session token generation, 
215-217 
time of check, time of use flaw 

(TOCTOU flaw), 505 
TOCTOU flaw. See time of check, 

time of use flaw 
tokens 
anti-CSRF, 508-509 

XSS defeating, 510-511 
authentication, 160 
Burp Sequencer testing 

randomness of, 219-221 
cloud computing attackers, 665 
encrypting, 223-233 
attackers, 232-233 
Burp Intruder bit flipper, 

228-231 
CBC, 227-233 
downloading, 231-232 
ECB ciphers, 224-226 
"reveal" encryption oracle, 
232 

generating strong, 248-249 
hacker's methodology, 

application mapping, 

sessions to, 818 
hacker's methodology, session 

management 



insecure transmission, 817 
system log disclosure, 

817-818 
tested for meaning, 815-816 
tested for predictability, 

816-817 
per-page, 252-253 
session management 
algorithm generating, 249 
attacker scripts, 217 
client-side exposure to 

hijacking of, 243-244 
concealed sequences, 213-215 
eavesdroppers, 234 
encrypting, 223-233 
HTTP cookies for, 207-208, 

234-236 
HTTPS, 234-236, 250 
life cycle protection, 250-253 
login function, 539-540 
meaningful, 210-212 
network disclosure, 234-237 
per-page, 252-253 
predictable, 213-223 
security, generation of, 210 
server-side technologies, 105 
strength, 248-249 
system log disclosure, 

237-239 
transmitting, 538 
URL transmission, 250 
in URLs, 237-238 
vulnerable mapping of, 

240-241 
weakness in generating, 

210-233 
weakness in handling, 

233-248 
XSS vulnerabilities, 243-244 
shared analyzers, integrated 

testing suites, 767 
SSL, 233 
static, 240 

structured, 210-212 
time dependency, 215-217 
weak random number 

generation, 218-219 
weak random number quality 
testing, 219-223 
TRACE functions, 43 
transaction logic, 844 
Trojan injection, XSS attack 

payloads, 444-445 
trust relationships 
hacker's methodology, 

application logic flaws, 
844 

tiered architectures 



access, 649 
exploiting, 649-650 
minimize, 654-655 
XSS attack payloads exploiting, 
446-447 
try-catch blocks, 30 

200 OK, 48 

201 Created, 48 

u 

UDFs. See user-defined functions 
UI redress attacks. See user 
interface redress attacks 
uid parameter, 584, 590 
unhandled errors, 30-31 
Unicode encoding, 67-68 

Burp Intruder, 375 
uniform resource identifier 
(URI), 44 
open redirection 

vulnerabilities, absolute 
prefix, 545-546 
uniform resource locator (URL) 
account activation, 184 
application mapping, input 

entry points, 98-99 
buffer overflow and length 

of, 639 
bytecode, 140 
encoding, 67 
SQL injection, 300-301 
truncating, 378 
format, 44 

HTTP requests, 40, 44 
open redirection 

vulnerabilities, 542 
absolute prefix, 545-546 
blocking absolute, 544-545 
parameters, client-side data 
transmission, 121-122 
passwords recovery with time- 
limited, 174-175 
redirection 
ASP.NET API methods, 723 
Java API methods, 716 
Perl language API methods, 
738 

PHP API methods, 731-732 
REST, 44-45 

spidering, 74-75 
session tokens, 237-238, 250 
translation attacks, 396-397 
UNION operator 
Boolean conditions, 329 
error messages, 306 
null value, 306-307 
Oracle databases, 307-308 



876 Index V-W 



provisos, 305-306 
SELECT NULL value, 306-307 
SELECT queries, 304-305 
SQL injection, 304-308 
data extraction, 308-311 
UNIX 

chrooted file system, 381 
Windows path traversal 

vulnerabilities compared 

to, 374 

UPDATE statements, 296-297 
uploaded files, stored XSS 
testing, 484-487 
Ajax, 486-487 
GIFAR files, 485-486 
URI. See uniform resource 

identifier 
URL. See uniform resource 

locator 
US-ASCII, 464 
user access. See access 
user input. See also input 
ASP.NET API methods for, 

718-719 
client-side controls, 117 
browser extensions, 133-153 
hacker's methodology, 

801-802 
HTML forms, 127-133 
Java, 711-712 

API methods, 712 
open redirection 

vulnerabilities, 543-544 
path traversal vulnerabilities, 

379-380 
Perl language, 735-736 
PHP, 724-727 
reflected XSS testing, 453 

script introduction, 454-455 
web application security 
threatened by, 9-10 
user interface redress attacks (UI 
redress attacks), 508, 511-515 
basic form, 511-513 
framebusting, 514-515 
mobile devices, 515 
preventing, 515 
variations, 513 
User-Agent header, 41, 52 

targeting, 100 
userData, IE, 554 
user-defined functions (UDFs), 
328 

user-directed spidering, 77-80 
benefits, 77 

hidden content discovery with, 
81-83 



web spidering compared to, 79 
_username buffer, 635-637 
usernames 
access controls attackers 
harvesting, 275-276 
attackers, 168 
e-mail address, 167, 196 
enumeration, 166-169 
hacker's methodology, 
authentication 
enumerating, 806-807 
uniqueness, 809 
nonunique, 181-182 
password change functionality, 
172 

predictable, 182-183, 197 

self-registration, 182, 196 

shared, 181 

sources, 169 

system-generated, 192 
UTF-7, 464 
UTF-16, 464-465 
UTL-HTTP package, 317-318 

V 

ValidateForm function, 130 
values clause, 295-296 
variable assignment, JavaScript 

hijacking, 522 
VBScript 
error messages, 616 
script code bypassing filters, 
467 

JavaScript with, 467-468 
web functionality, 61 
vendor patches, web servers, 695 
verbose debugger messages, 425 
verbose error message, 30-31, 

624 

verbose failure messages, 

166-169 
vertical access controls, 258 
vertical privilege escalation, 

258, 416 
ViewState, ASP.NET 
attackers, 127 
Base64 encoding, 125-126 
Burp Suite, 126 
client-side data transmission, 

124-127 
purpose, 125 
security, 155 
virtual defacement, XSS attack 

payloads, 443-444 
virtual hosting 
Apache, 683 



hacker's methodology, web 

servers, 847-848 
shared hosting, 657 
web servers misconfigured, 

683 

virtual machines (VMs), 145 

sandbox, 153 
virtual private network (VPN), 
659 

VMs. See virtual machines 
VPN. See virtual private network 
vulnerability scanners 
integrated testing suites, 
764-765 
standalone, 773-784 
standalone, 773-784 
automated versus user- 
directed, 784 
customized automation, 

780-781 
dangerous effects, 779 
individuating functionality, 

779-780 
limitations, 776-777 
products, 781-782 
technical challenges, 778-781 
using, 783-784 
vulnerabilities detected, 

774-776 
vulnerabilities undetected, 
775 

w 

WAFs. See web application 

firewalls 
WAITFOR command, MS-SQL, 

322-323 
WAR files, 673-676 
warez, distributing, 2 
WayBack Machine, 89 
WCF. See Windows 

Communication Foundation 
weak passwords, 161-162 
web 2.0, 14 

vulnerabilities, 65 
web application firewalls (WAFs) 
bypassing, 698 
hacker's methodology, web 

servers, 848-849 
NULL bytes, 460 
web servers, 697-698 
web applications. See also 
hacker's methodology; 
hacker's toolkit 
administrative functions in, 
35-36 



Index W-W 877 



ASP attackers between, 

660-663 
behavior 

extrapolating, 109-110 

isolating, 110 
benefits, 5-6 
business, 4 
cloud computing, 5 
custom development, 10 
data store reliance of, 287 
deceptive simplicity, 10-11 
evolution, 2-3 
framework flaws, 685-687 
functions, 4-5 

increasing demands on, 12 
managing, 35-36 
overextended, 11-12 
pages, functional paths versus, 

93-96 
security, 1, 6-15 

attackers, 6 

developer understanding, 3 
future, 14-15 
key factors, 10-12 
new network perimeter for, 
12-14 

user input threatening, 9-10 
vulnerabilities, 7-8 
shared hosting attackers 

between, 660-663 
technologies developing, 6 
third-party, 560-561 
threats to, 3 

rapidly evolving, 11 
XPath subverting logic of, 
345-346 
web archives, public 

information, 89-90 
web browsers. See also browser 
extensions; Firefox; Internet 
Explorer 
attackers, 559-568 
browsing history, 552 
bugs, 563 
capabilities, 5-6 
DNS rebinding, 563-564 
exploitation frameworks, 
564-566 
BeEF, 565-566 
XSS Shell, 566 
hacker's toolkit, 748-750 
Chrome, 750 
Firefox, 749-750 
IE, 748-749 
integrated testing suites, 
intercepting proxies 
configuring, 752-755 



XSS filters, 479-481 
web container, Java, 53 
web functionality 
client-side, 57-65 

Ajax, 62-63, 384 

browser extension 
technologies, 65 

CSS, 60-61 

DOM, 62 

forms, 58-60 

HTML, 58 

HTML5, 64-65 

hyperlinks, 58 

JavaScript, 61 

JSON, 63 

same-origin policy, 64 

VBScript, 61 
server-side, 51-57, 103, 106-110 

ASP.NET, 54, 103 

Java, 53-54 

PHP, 54-55 

Ruby on Rails, 55 

SQL, 55-56 

web services, 56-57 

XML, 56 
sessions, 66 
state information, 66 
web servers, 669-670 
CMS, 92 
configuration 

security, 684 

vulnerabilities, 670-684 
default content, 92, 671-677 

debug functionality, 671-672 

hacker's methodology, 847 

JMX, 674-676 

powerful functions, 673-674 

sample functionality, 672-673 
default credentials, 670-671 

hacker's methodology, 846 
directory listing, 677-679 

Allaire JRun, 690-691 
flaws, 694 

hacker's methodology, 846-849 
dangerous HTTP methods, 
847 

default content, 847 
default credentials, 846 
native software bugs, 848 
proxy server functionality, 
847 

virtual hosting, 847-848 
WAFs, 848-849 
hidden content discovery 

leveraging, 91-93 
JBoss Application Server, 
674-676 



misconfigured virtual hosting, 
683 

Oracle, 676-677 

as proxy servers, 682-683 

software 
Allaire JRun, 690-691 
Apple iDisk Server, 690 
defense in depth, 696-697 
encoding and 

canonicalization, 
689-694 
JVM, 690 

memory management, 

687-689 
Microsoft IIS path traversal 

vulnerabilities, 691-692 
Oracle PL/SQL Exclusion 
List filter bypass, 
692-694 
resources, 694 
Ruby WEBrick, 690 
securing, 695-697 
security hardening, 695-696 
vendor patches, 695 
vulnerabilities, 684-697 
vulnerabilities, 91-92 
WAFs, 697-698 
WebDAV methods, 679-681 
web services, 56-57 
Web Services Description 
Language (WSDL), 57 
web spidering, 74-77 
authentication, 76 
integrated testing suites, 

760-762 
user-directed spidering 
compared to, 79 
web storage 
cloud computing, 665 
hacker's methodology, 

authentication insecure, 
811 

Web-based Distributed 

Authoring and Versioning 
(WebDAV) 
overflows, 689 

web server methods, 679-681 
WebDAV. See Web-based 

Distributed Authoring and 
Versioning 
WEBrick, Ruby, 690 
websites 
attacker-created, 448-449 
evolution, 51 

security and evolution of, 2 
web . xml file, 716-717 
Wget, 788 



878 Index ■ X-Z 



WHERE clause 
DELETE statements, 297-298 
INSERT statements, 295 
SELECT statements, 321 
UPDATE statements, 296-297 
white-box code review, 702-703 
whitelist-based filters, 24 
wiki, brute-force techniques for 

passwords in, 424 
Wikto, hidden content, 
92-93 

Windows, UNIX path traversal 
vulnerabilities compared 
to, 374 

Windows Communication 
Foundation (WCF), 138 
Winter-Smith, Peter, 640 
Wireshark, 236 
Witko, 785 

World Wide Web. See also 

hypertext transfer protocol; 
web functionality 



evolution, 2-3, 15 
overextended technologies in, 
11-12 

WSDL. See Web Services 
Description Language 



. xap files, 141 

X-Frame-Options header, 

515 
XHTML, 58 

XML. See Extensible Markup 

Language 
XML external entity injection 
(XXE injection), 384-386 
hacker's methodology, 
841 

XML Path Language (XPath) 
count { ) function, 348 
injection, 344-349 
blind, 347-348 
flaws, 348-349 



hacker's methodology, 

840-841 
informed, 346-347 
preventing, 349 
keywords, 346 

string-length ( ) function, 
348 

subverting web application 
logic, 345-346 
XMLHttpRequest, 62-63, 476, 
524 

attackers, 529 

cross-domain requests, 
528-529 
XPath. See XML Path Language 
XSS. See cross-site scripting 
XSS Shell, 566 

XXE injection. See XML external 
entity injection 

z 

.zip extension, 141 



ENDED
